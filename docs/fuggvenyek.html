<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="hu-HU" xml:lang="hu-HU"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Ez a jegyzet bevezetést nyújt az R nyelv és számítási környezet használatába, mely a statisztikai, adatelemzési feladatok megoldásának egy nagyon erőteljes eszköze.">

<title>3&nbsp; Függvények – Bevezetés az R nyelv és statisztikai számítási környezet használatába</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./programozas.html" rel="next">
<link href="./adattipusokadatszerkezetek.html" rel="prev">
<link href="./Rlogo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-70a47bd5681a7291082a5b9f83d58762.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nincs találat",
    "search-matching-documents-text": "találat",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "További találatok elrejtése",
    "search-more-match-text": "további találat ebben a dokumentumban",
    "search-more-matches-text": "további találat ebben a dokumentumban",
    "search-clear-button-title": "Törlés",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Mégse",
    "search-submit-button-title": "Keresés",
    "search-label": "Keresés"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="3&nbsp; Függvények – Bevezetés az R nyelv és statisztikai számítási környezet használatába">
<meta property="og:description" content="Ez a jegyzet bevezetést nyújt az R nyelv és számítási környezet használatába, mely a statisztikai, adatelemzési feladatok megoldásának egy nagyon erőteljes eszköze.">
<meta property="og:image" content="https://ferenci-tamas.github.io/r-nyelv/cover.png">
<meta property="og:site_name" content="Bevezetés az R nyelv és statisztikai számítási környezet használatába">
<meta property="og:image:height" content="630">
<meta property="og:image:width" content="1200">
<meta name="twitter:title" content="3&nbsp; Függvények – Bevezetés az R nyelv és statisztikai számítási környezet használatába">
<meta name="twitter:description" content="Ez a jegyzet bevezetést nyújt az R nyelv és számítási környezet használatába, mely a statisztikai, adatelemzési feladatok megoldásának egy nagyon erőteljes eszköze.">
<meta name="twitter:image" content="https://ferenci-tamas.github.io/r-nyelv/cover.png">
<meta name="twitter:image-height" content="630">
<meta name="twitter:image-width" content="1200">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./fuggvenyek.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Függvények</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Keresés" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Bevezetés az R nyelv és statisztikai számítási környezet használatába</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/ferenci-tamas/r-nyelv" title="Forráskód" class="quarto-navigation-tool px-1" aria-label="Forráskód"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Letöltés" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Letöltés"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./ferenci-tamas-r-nyelv.pdf">
              <i class="bi bi-file-pdf pe-1"></i>
            Letöltés PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./ferenci-tamas-r-nyelv.epub">
              <i class="bi bi-journal pe-1"></i>
            Letöltés ePub
            </a>
          </li>
      </ul>
    </div>
    <div class="dropdown">
      <a href="" title="Megosztás" id="quarto-navigation-tool-dropdown-1" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Megosztás"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-1">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Keresés"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Előszó</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rbevezetes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">R szkriptek és az RStudio</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./adattipusokadatszerkezetek.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Adattípusok, adatszerkezetek</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fuggvenyek.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Függvények</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programozas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Az R programozása</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./datatable.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Data table: egy továbbfejlesztett adatkeret</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tartalomjegyzék</h2>
   
  <ul>
  <li><a href="#paraméterátadás-és-visszatérési-érték" id="toc-paraméterátadás-és-visszatérési-érték" class="nav-link active" data-scroll-target="#paraméterátadás-és-visszatérési-érték"><span class="header-section-number">3.1</span> Paraméterátadás és visszatérési érték</a></li>
  <li><a href="#saját-függvények-létrehozása" id="toc-saját-függvények-létrehozása" class="nav-link" data-scroll-target="#saját-függvények-létrehozása"><span class="header-section-number">3.2</span> Saját függvények létrehozása</a></li>
  <li><a href="#r-csomagok-használata" id="toc-r-csomagok-használata" class="nav-link" data-scroll-target="#r-csomagok-használata"><span class="header-section-number">3.3</span> R csomagok használata</a></li>
  <li><a href="#függvények-specifikációja-és-meghívása" id="toc-függvények-specifikációja-és-meghívása" class="nav-link" data-scroll-target="#függvények-specifikációja-és-meghívása"><span class="header-section-number">3.4</span> Függvények specifikációja és meghívása</a></li>
  <li><a href="#az-r-ben-minden-utasítás-függvényhívás" id="toc-az-r-ben-minden-utasítás-függvényhívás" class="nav-link" data-scroll-target="#az-r-ben-minden-utasítás-függvényhívás"><span class="header-section-number">3.5</span> Az R-ben minden utasítás függvényhívás</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/ferenci-tamas/r-nyelv/edit/main/fuggvenyek.qmd" class="toc-action"><i class="bi bi-github"></i>Az oldal szerkesztése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/blob/main/fuggvenyek.qmd" class="toc-action"><i class="bi empty"></i>Forráskód megtekintése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/issues/new" class="toc-action"><i class="bi empty"></i>Észrevétel jelzése</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Függvények</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Sok esetben előfordul, hogy egy statisztikai programban ismétlődő részek vannak. Tekintsük például a következő kódot (<code>x</code> egy valós számokat tartalmazó vektor):</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">10</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] -0.4650108 -0.6436045  0.5136171  0.2732740 -0.4356120  1.9632869
 [7] -0.7406694 -0.8647298 -1.8927236  0.1233456</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>osszeg <span class="ot">&lt;-</span> <span class="fu">sum</span>(x)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>atlag <span class="ot">&lt;-</span> osszeg<span class="sc">/</span>n</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>((x <span class="sc">-</span> atlag)<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span>(n <span class="sc">-</span> <span class="dv">1</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.048531</code></pre>
</div>
</div>
<p>Valószínűleg sokan felismerik, hogy ezzel az <code>x</code>-ben lévő elemek varianciáját számoltuk ki. Erre ezerszer szükség lehet egy statisztikai elemzésben: egyszer kiszámolhatjuk a testtömegek varianciáját, aztán a testmagasságokét, kellhet varianciát számolni, ha valamilyen regressziót futtatunk, ha főkomponens-elemzést hajtunk végre, egyszóval milliónyi feladatnál, akár ugyanazon szkripten belül is, pláne a különböző szkriptekben.</p>
<p>Megtehetnénk természetesen, hogy minden ilyen esetben elhelyezzük ugyanazt a kódrészletet: kimásoljuk a fentit, és mindenhová beillesztjük, <code>x</code>-et a megfelelő változónévre cserélve – de remélhetőleg zsigerből érezhető, hogy ez nagyon-nagyon szerencsétlen megoldás lenne. Azon túl, hogy nagyon hosszúvá tenné a kódot (ami nem a gépnek probléma, hanem nekünk, olvashatóság szempontjából), azon túl, hogy megnehezíti a kód elemzését, értelmezését, mert nem lesz gyorsan és egyértelműen beazonosítható, hogy mely helyeken történik meg ez a számolás, a fő probléma, hogy borzasztóan megnehezítené a kód karbantartását, a hibajavításokat, fejlesztéseket. Képzeljük el például, hogy miután végeztünk a fenti bemásolgatós megoldással, észrevesszük, hogy az <code>osszeg</code> változót teljesen felesleges volt elmenteni, mert csak egyetlen egyszer hivatkozunk rá, nyugodtan beírhattuk volna közvetlenül a következő sorba. Mit csinálunk? Ha a bemásolgatós megoldással éltünk, akkor nincs más lehetőség, mind az ezer helyen át kell írni…!</p>
<p>Mennyivel jobb lenne ezt a kódot csak egyetlen egy helyen megírni, adni neki egy nevet, mondjuk <code>variancia</code>, és minden alkalommal, amikor szükség van rá a programunkban, azt írni ott, hogy „most futtasd le a <code>variancia</code>-t”. Egyetlen rövid utasítás, ami azt jelentené, hogy innentől ugorj át erre az – egyetlen helyen megírt – kódra, futtasd le, ami ott van, majd ha végeztél, térj vissza pontosan oda, ahol mondtuk, hogy futtasd le ezt a kód. Az ilyen kódot hívjuk úgy a programozásban, hogy függvény, az előbbi folyamatra pedig azt mondjuk, hogy meghívtuk a függvényt. Mindezt akárhány alkalommal megtehetjük, mindig ugyanaz az – egyetlen helyen megírt – függvény fut le, és a végén mindig oda ugrik vissza, ahonnan éppen hívtuk. A fenti kódot, a függvény „tartalmát” a függvény törzsének szoktuk mondani.</p>
<p>Ezzel a módszerrel sokkal olvashatóbb lesz a kód, azonnal és egyértelműen látszódni fog, hogy hol használtuk ezt a variancia-számítást, de a legfontosabb, hogy ha valamit módosítanunk kell a variancia-számításban, akkor ezt elég egy helyen megtenni, és ettől automatikusan az összes hívásnál meg fog változni.</p>
<section id="paraméterátadás-és-visszatérési-érték" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="paraméterátadás-és-visszatérési-érték"><span class="header-section-number">3.1</span> Paraméterátadás és visszatérési érték</h2>
<p>Egyetlen egy dolgot kell megoldani, az információk átadását. Mindkét irányban: valahogy el kell juttatnunk a függvényhez, hogy mi az a vektor, aminek a varianciáját számolni akarjuk, illetve fordítva, valahogy vissza kell juttatnunk a kiszámított varianciát a programhoz.</p>
<p>Az előbbi megoldás kinézetét már sugallja a fenti kód is: a függvényben meghatározunk egy változónevet (<code>x</code>), és azon hajtjuk végre a műveleteket a függvény törzsében, az információátadást pedig úgy valósítjuk meg, hogy a függvény hívásakor megadjuk, hogy milyen konkrét érték, például programbeli változó – mondjuk <code>testtomegek</code> – kerüljön át a függvénybe ezen a néven. Az ilyen <code>x</code>-et szép néven paraméternek, a konkrét értéket, amit a függvény híváskor megadunk, argumentumnak nevezzük<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>; az egész mechanizmus neve pedig paraméterátadás. Lényegében az történik, hogy <code>x</code> szerepét a <code>testtomegek</code> változó fogja játszani – ennél a hívásnál. De később, ha meghívjuk a függvényt a <code>testmagassagok</code> argumentummal, akkor az fogja <code>x</code> szerepét játszani. Nekünk a függvényben azonban általánosan kellett meghatározni, hogy mit kell tenni, erre szolgál az <code>x</code>, azon írjuk le, hogy mi <em>általában</em> az eljárás, arról pedig az R gondoskodik, hogy ez mindig a megfelelő értéken hajtódjon végre. A háttérben az történik, hogy amikor meghívjuk a függvényt a <code>testtomegek</code> változóval mint argumentummal, akkor az R készít egy másolatot a <code>testtomegek</code>-ről, elnevezi <code>x</code>-nek, és lefuttatja rajta a függvény törzsét. A „készít róla másolatot” kitétel fontos, ez ugyanis azt is jelenti, hogy a függvény törzse bármit is csinál az <code>x</code>-szel, az nem fog visszahatni a hívó programban található <code>testtomegek</code> változóra: ha a függvény át is írja <code>x</code>-et, attól még a <code>testtomegek</code> a hívó programban ugyanaz marad (hiszen ilyenkor a függvény csak a <code>testtomegek</code> egy <em>másolatát</em> módosította, aminek semmi köze a <code>testtomegek</code>-hez!). Ezt szokták érték szerinti paraméterátadásnak nevezni<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Egyetlen megjegyzés a végére: ne ijedjünk meg a „készít róla másolatot” megfogalmazástól. Ezt csak az elmagyarázást segítő szófordulat volt a részemről, az R ezt igyekszik ügyesen kezelni, és nem feltétlenül készít<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ténylegesen másolatot, azaz a dolog nem jelenti automatikusan azt, hogy minden függvényhívásnál teljesítmény-veszteség keletkezik a másolgatások miatt, aminek van valamennyi időigénye.</p>
<p>És mi a helyzet fordított irányban? Hogyan adhatunk vissza információt a hívó programnak? Az első dolog, amit tudni kell, hogy R-ben egy függvény csak <em>egyetlen</em> értéket adhat vissza<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>; ezt hívjuk visszatérési értéknek. Ez elsőre rosszul hangozhat, de ne ijedjünk meg, ez semmilyen érdemi limitációt nem jelent: a visszatérési érték ugyanis nyugodtan lehet egy lista is! Abba pedig akármilyen objektumból akármennyit bepakolhatunk. A visszatérési értéket megadni a <code>return</code>-nel lehet, a fenti példában azt kellene írnunk az utolsó sorban, hogy <code>return(sum((x - atlag)^2)/(n - 1))</code>. Ez azt jelenti, hogy a függvény végrehajtása befejeződik, a vezérlés visszakerül a hívó programhoz, olyan módon, hogy a függvényhívás behelyettesítődik a visszatérési értékkel. Ez utóbbi nagyon fontos: a dolgot úgy kell elképzelnünk, mintha a meghívott függvény helyébe odaírnánk a visszatérési értékét, és úgy menne tovább a végrehajtás. Két technikai megjegyzés a végére. Az egyik, hogy nem kötelező, hogy a <code>return</code> legyen egy függvény utolsó utasítása, de mivel a <code>return</code> elérésekor a vezérlés visszakerül a hívóhoz, így túl sok értelme sincs bármit utána írni. Jellemzően akkor fordul elő, hogy <code>return</code>-t látunk egy függvény közepén, ha valójában egy feltételes részben van, tehát nem biztos, hogy végrehajtódik: a <code>return</code> megvalósítja azt, hogy <em>ha</em> oda kerül a végrehajtás, akkor visszatér (és így a függvény többi része végre sem hajtódik), de ha nem, akkor a <code>return</code> le sem fut, és így mehet tovább a függvényben a végrehajtás. A másik megjegyzést talán még gyakrabban használjuk a gyakorlatban, ez pedig az a szabály, hogy ha a függvényben egyáltalán nincs <code>return</code>, akkor a visszatérési érték az utolsóként kiértékelt kifejezés értéke lesz. Ez a gyakorlatban azért fontos, mert elég tipikus, hogy egy függvény utolsó utolsó utasítása egyszerűen egy változó neve, vagy valamilyen egyszerű művelet egy változóval – ekkor ez az érték fog automatikusan <code>return</code>-ölődni. A fenti példában tehát igazából elég lenne a függvény utolsó sorában annyit írni, hogy <code>sum((x - atlag)^2)/(n - 1)</code>, a <code>return</code> nem is kell, az eredmény ugyanaz lesz.</p>
<p>Ha egy függvény bármilyen más hatást vált ki azon kívül, hogy kiszámolja a visszatérési értéket és azt visszaadja, akkor azt mellékhatásnak nevezzük, az ilyen függvényt pedig mellékhatásos függvénynek. Ez elsőre meglepő lehet (mégis mi más hatása lehet egy függvénynek azon kívül, hogy kiszámolja a visszatérési értéket és azt visszaadja?!), de ha meggondoljuk, valójában egészen banális dolgok tartoznak ide – kezdjük például kapásból a kiíratással! Az ugyanis teljes mértékben egy mellékhatás: ha egy függvény hatására valami megjelenik a konzolon, annak nyilván semmi köze a visszatérési értékhez. De az is mellékhatás, ha egy fájlt kiírunk a merevlemezre, vagy mondjuk ha megjelenítünk egy ábrát. Az R programozási filozófiája miatt alapvetően kerülni célszerű a mellékhatásokat<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, de mint az előbbi példák mutatják, bizonyos esetben elkerülhetetlenek.</p>
</section>
<section id="saját-függvények-létrehozása" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="saját-függvények-létrehozása"><span class="header-section-number">3.2</span> Saját függvények létrehozása</h2>
<p>A fentiekkel szinte már mindent tudunk ahhoz, hogy saját függvényt tudjunk definiálni. Amint láttuk, ez fontos: ez minden alkalommal jól jön, ha ismétlődő kódrészletek vannak a statisztikai számításunkban. Nézzük, hogyan tehetjük ezt meg egész pontosan.</p>
<p>Először is, függvényt ugyanúgy értékadással hozhatunk létre, ahogy létrehozunk egy – korábban még nem létező – változót. Amit a változónak értékül kell adnunk, az a <code>function</code> kulcsszó, ennek hatására a létrejövő változó egy függvény lesz, amit később meghívhatunk. A <code>function</code> után gömbölyű zárójel következik, benne a paraméterek – ennek részleteit a következő pontban fogjuk látni – utána pedig a függvény törzse. Ez egyetlen R kifejezés lehet, ami persze az esetek túlnyomó többségében értelmetlenül kevés, de semmi gond: erre szolgál a blokk-képzés. A blokk-képzés azt jelenti, hogy fogunk utasításokat, és összefogjuk őket egyetlen egységbe – ez lesz a blokk – amik úgy viselkednek, mintha az egyetlen kifejezés lenne. (A végrehajtása természetesen azt jelenti, hogy mindegyik benne lévő utasítás végrehajtódik egymás után, ahogy bármilyen R kódnál történne.) A blokk-képzés jele az R-ben a kapcsos zárójel, ezzel lehet több utasítást egyetlen blokkba összefogni.</p>
<p>Mindezek alapján egy saját függvény létrehozása a következőképp néz ki a fenti példában:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>variancia <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  osszeg <span class="ot">&lt;-</span> <span class="fu">sum</span>(x)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  atlag <span class="ot">&lt;-</span> osszeg<span class="sc">/</span>n</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sum</span>((x <span class="sc">-</span> atlag)<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span>(n <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Ezután bármikor meghívhatjuk:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">10</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">variancia</span>(x)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.317466</code></pre>
</div>
</div>
<p>(Természetesen erre a célra van beépített – és a fentinél sokkal gyorsabb – függvény, a neve <code>var</code>, de ez most csak az illusztráció célját szolgálta.)</p>
<p>Ami feltűnhet a fentiben, hogy sem a paraméterek, sem a visszatérési érték típusát nem kellett megadni. Ez következik abból, hogy az R dinamikus típusrendszerű nyelv, és minden igaz rá, amit a dinamikus típusrendszerről az adattípusoknál elmondtunk: egyszerűsíti az életet (nem kell vacakolni a típusok felsorolásával, nyugodtan előfordulhat, hogy az argumentumok fényében nem mindig ugyanolyan típusú eredményt adunk vissza), de cserében megszüntet egy védelmi vonalat, ami kinyit hibalehetőségeket. Nem csak arról van szó, hogy a fenti függvényt meghívhatjuk például egyelemű vektorral – ami az <code>n-1</code>-gyel való osztás miatt lesz elég nagy baj – de az előzőekben mondottak miatt még az ellen sem lesz beépített védelmünk, hogy valaki mondjuk egy szöveg varianciáját álljon neki kiszámíttatni…! Az R-ben minden ilyenre nekünk kell figyelni. És érdemes is: ilyen esetekben fontos lehet, hogy mielőtt bármit csinálunk, ellenőrizzük a kapott argumentumot vagy argumentumokat; erre vannak bevált eszközök és módszerek<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> az R-ben. Ez különösen akkor helyes gyakorlat, ha a függvényt nem csak mi magunk fogjuk meghívni – ekkor még mondhatnánk, hogy a meghívó oldaláról tudjuk biztosítani a megfelelő argumentumokat, bár az igazság az, hogy ilyenkor is sokszor jobb a biztonság – hanem mások is meghívhatják, például, mert egy R csomagba kerül ki.</p>
<p>Az R programozásáról szóló fejezetben látni fogjuk, hogy lesznek olyan függvények amelyeknek az egyik argumentuma maga is függvény. Ez lehet egy fentihez hasonló függvény: létrehozunk egy függvényt, nevet adunk neki, majd ezt a nevet adjuk meg ilyenkor argumentumként. Ilyen esetekben azonban elég gyakori, hogy a függvényt nem akarjuk külön elmenteni, saját néven, ugyanis máshol nincsen rá szükség, és csak ott akarnánk, direkte a kódba beleírni a függvényt az argumentum helyébe, anélkül, hogy előtte külön néven elmentjük. (Lényegében arról van szó, hogy szeretnénk megtenni ugyanazt a függvényekkel, amit megtehetünk más kifejezésekkel. Hiszen ha például gyököt akarunk vonni <code>3 + 1</code>-ből, akkor egyáltalán nem kötelező előbb bementeni egy külön, névvel rendelkező változóba a <code>3 + 1</code>-et, majd arra a változóra meghívni a <code>sqrt</code>-ot, egész nyugodtan megtehetjük azt is, hogy azt írjuk, hogy <code>sqrt(3 + 1)</code>.) A helyzet az, hogy ez minden további nélkül működik függvényekkel is! A fenti szintaktikával kell létrehozni függvényt, de egyáltalán nem kötelező, hogy azt bármibe belenyilazzuk. Az így létrehozott függvény nyugodtan beírható az argumentum helyébe, a dolog tökéletesen működőképes lesz. Az ilyen függvényt hívjuk szép szóval anonim függvénynek.</p>
<p>Egyetlen megjegyzés a végére. Az R 4.1.0-s verziója bevezetett egy rövidítést: a <code>\(x)</code> pontosan ugyanaz mint a <code>function(x)</code>. Ezt inkább anonim függvényeknél szokták használni, hiszen ott jobban mutat, ha kevesebbet kell írni, mivel ott a függvény egy másik függvény argumentumába van beírva, ami elég zsúfolt kódot eredményezhet már eleve is.</p>
</section>
<section id="r-csomagok-használata" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="r-csomagok-használata"><span class="header-section-number">3.3</span> R csomagok használata</h2>
<p>Volt már róla szó, hogy az R erejét nem kis részt az adja, hogy hihetetlen mennyiségű csomag érhető el hozzá, melyek a legkülönfélébb statisztikai problémák megoldását teszik lehetővé. Most már pontosabb definícióját adhatjuk annak, hogy mi az egyáltalán, hogy R csomag: tartalmilag összetartozó függvények gyűjteménye (dokumentációval és esetleg adatokkal kiegészítve). Nézzük meg részletesebben, hogy miről van szó!</p>
<p>Amikor azt mondtam, hogy „statisztikai problémák megoldása”, akkor azt lényegében így értettem: megfelelő függvények megírása. Hiszen ezeket a statisztikai problémákat éppen úgy oldjuk meg, hogy létrehozunk (egy vagy több) függvényt! A megoldás abban manifesztálódik, hogy létrehozunk függvényt vagy függvényeket, amik a szükséges számításokat elvégzik, tehát tömörítik a statisztikai tudásunkat azáltal, hogy a feladatot – vagy valamilyen részfeladatát – megoldják, ahogy a fenti függvény megoldja a variancia kiszámításának a feladatát. Azzal a nem elhanyagolható eltéréssel, hogy a függvény természetesen nem biztos, hogy 4 sor, lehet éppenséggel 4 ezer is. Elég tipikus, hogy egy adott témakör számításai több függvényt igényelnek, ezeket dokumentációval kell ellátni, néha érdemes adatbázisokat is mellékelni – az R csomag nem más, mint ilyenek gyűjteménye. Amikor betöltünk egy R csomagot, akkor elérhetővé válnak a benne definiált függvények, vagyis azáltal „férünk hozzá az erejéhez”, hogy meg tudjuk hívni ezeket a függvényeket, így egyetlen sorban elérünk néha több ezer sornyi, adott esetben igen komplex statisztikai számítást, amit más, jó esetben a témában jártas szakértők megírtak számunkra, így mi készen használhatjuk.</p>
<p>Kis kitérő: eddig még nem töltöttünk be semmilyen csomagot, és mégis voltak elérhető függvényeink, mint az <code>rnorm</code> vagy a épp az <code>str</code>. Eddig ezt úgy kezeltem, mintha ezek valamiféle „beépített” függvények lennének, amikhez nem kell csomagot betölteni… csakhogy ez nem igaz. Ezek szintén csomagban vannak, ugyanúgy mint bármely más függvény (általában is, ha megnézzük egy függvény súgóját, akkor a bal felső sarokban, kapcsos zárójelben látjuk, hogy melyik csomagban, innen kiderül, hogy az <code>rnorm</code> a <code>stats</code>-ban, az <code>str</code> a <code>utils</code>-ban van), és ezeket a csomagokat nagyon is be kell tölteni, hogy elérjük a függvényeiket – csak épp az R ezt megteszi helyettünk! Van ugyanis hét csomag<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> amit az R az indulásakor <em>automatikusan</em> betölt, így a függvényei elérhetővé válnak úgy, hogy látszólag nem kellett semmit sem tennünk – de a valóságban ez is ugyanúgy csomagbetöltés volt.</p>
<p>Még mielőtt a csomagok betöltésére térünk, egy dolgot meg kell beszélni: a csomagok telepítését, betölteni ugyanis csak telepített csomagot<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> tudunk. Bárki készíthet R csomagot, egy R csomag lehet egyetlen összecsomagolt zip-fájl, de van egy eszköz, ami miatt mégsem alakul ki káosz ebből a dologból, azaz nem zip-fájlok keringenek össze-vissza, ez az eszköz pedig nem más, mint a CRAN (Comprehensive R Archive Network). Ez az R csomagok egy központi repozitóriuma, ahol szinte minden fontos R csomag megtalálható, így ez kiküszöböli a káoszt: szinte mindenki erre az egy helyre tölti fel az R csomagját, ha készít ilyet, és szinte mindenki erről az egy helyről tölti le az elkészített R csomagokat. (A „szinte” kitétel annak szól, hogy léteznek más repozitóriumok is, megfelelő csomag segítségével lehet Github-repozitóriumból is installálni csomagot, illetve elvileg lehet tényleg zip-fájlból is telepíteni csomagot, de ezek jelentősége eltörpül a CRAN mellett.) A CRAN ráadásul ellenőrzi is a csomagot, egyébként elég szigorúan, tehát ez egyfajta minőségbiztosítás is. (Mindazonáltal az ellenőrzés formai, tehát a csomag szintaktikai helyességére vonatkozik, nem a statisztikai – vagy bármilyen más – tartalmának tudomány helyességére!) A CRAN-ről történő telepítéshez az R külön utasítást tartalmaz, így valójában nem kell semmilyen zip-fájl letöltéssel vesződnünk. Ha RStudio-t használunk, akkor választhatjuk egyszerűen a Tools menü Install packages pontját, itt alapértelmezett a CRAN-ről történő telepítés, így csak a csomag nevét – vagy több csomag esetén a neveiket, vesszővel elválasztva – kell megadni, ebben automatikus kiegészítés segít is, majd az Install gombra kattintva megtörténik a telepítés. A konzolon láthatjuk, hogy ez igazából egyenértékű az <code>install.packages</code> függvény meghívásával, argumentumként megadva a csomag nevét; válaszhatjuk ezt a megoldást is. (Viszont ezt nem illik magába a szkriptbe beleírni, mert ez azt jelentené, hogy ha az egész szkriptet egyben futtatjuk, akkor az minden alkalommal nekiáll telepíteni a csomagot.) Ha egyszer megtörtént a telepítés<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, onnantól már betölthetjük a csomagot.</p>
<p>Hogy legyen egy konkrét példánk csomag betöltéséhez, tekintsük azt a feladatot, hogy szeretnénk 10 véletlenszámot generálni, de ezúttal egy standard inverz exponenciálisnak nevezett eloszlásból. Hogy mi ez az eloszlás, az most mindegy is, ami viszont fontos, hogy – szemben a normálissal – az R erre nem tartalmaz „beépített” függvényt. De semmi vész, szerencsére az <code>actuar</code> nevű csomagban van egy függvény, a neve <code>rinvexp</code>, ami pont ezt valósítja meg! Első pont: ha korábban nem tettünk meg, telepítenünk kell az <code>actuar</code> csomagot; e nélkül nem tudunk továbbhaladni. Második pont: ha telepítettük, akkor be kell tölteni.</p>
<p>Ezen a ponton kettéágaznak a lehetőségek. Még mielőtt belevágunk, elsőként állapítsuk meg, hogy betöltés nélkül nem tudjuk lefuttatni a függvényt, hibát fog adni:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rinvexp</span>(<span class="dv">10</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<pre><code>Error in rinvexp(10): could not find function "rinvexp"</code></pre>
</div>
</div>
<p>Az első lehetőség, hogy a <code>::</code> (két kettőspont, néha szokták magyarul négyespontnak is hívni) operátort használjuk: először leírjuk a csomag nevét, utána négyespontot teszünk, majd a függvény nevét a csomagból. Ez így már lefut:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>actuar<span class="sc">::</span><span class="fu">rinvexp</span>(<span class="dv">10</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  3.4424548  1.5555328 19.9458261  6.5262191  1.0578041  2.1200143
 [7]  0.9484391  0.6031417  0.2757348  0.5826413</code></pre>
</div>
</div>
<p>Magyarra lefordítva az <code>actuar::rinvexp</code> praktikusan azt jelenti, hogy „az <code>actuar</code> csomag <code>rinvexp</code> nevű függvénye”.</p>
<p>Ez nem szó szerint a csomag betöltése, abban az értelemben, hogy ettől nem válik a csomag összes többi függvénye elérhetővé, csak ez az egy (és ez az egy is csak ekkor, ha később újra szükségünk van erre a függvényre, akkor megint elé kell írni, hogy <code>actuar::</code>). A csomag szó szerinti betöltését a <code>library</code> függvénnyel<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> hajthatjuk végre:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(actuar)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Kapcsolódás csomaghoz: 'actuar'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:stats':

    sd, var</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:grDevices':

    cm</code></pre>
</div>
</div>
<p>Ha ezt megtettük, akkor onnantól nincs szükség a <code>::</code> operátorra, a csomag valamennyi függvénye automatikusan, minden előtag nélkül elérhetővé válik! Azaz innentől működik ez a megoldás is:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rinvexp</span>(<span class="dv">10</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 63.6899950  1.0134116 43.8038219  0.9412702  2.1345311  0.7567085
 [7]  0.5334478  4.8877560  1.0358613  1.1625287</code></pre>
</div>
</div>
<p>Egy apró megjegyzés a teljes precizitás kedvéért. A négyespont operátor csak azokat a függvényeket teszi elérhetővé, amik ún. exportált függvényei a csomagnak. Az exportálás lényegében azt jelenti, hogy elérhetővé akarjuk-e tenni az adott csomagbeli függvényt. Ez elsőre meglepő lehet (miért raknánk egy függvényt egy csomagba, ha nem akarjuk elérhetővé tenni?!), de elképzelhetőek helyzetek, ahol ennek van értelme, például, mert csak egy belső célokat szolgáló segédfüggvényről van szó – az ilyeneknek lehet szerepe, a felhasználó számára is, mert <em>más</em> csomagbeli függvények meghívhatják, csak közvetlenül nem lehet őket kívülről meghívni. Ha valami oknál fogva mégis ezt szeretnénk, akkor a <code>:::</code> operátort kell használni, ezzel nem exportált függvény is hívható.</p>
<p>A nyitva maradt kérdés, hogy melyik a jobb megoldás, a <code>::</code> használata vagy a <code>library</code>-vel történő betöltés? A válaszhoz egy dolgot kell még tudni, azt, hogy mi történik akkor, ha a csomagban van egy olyan nevű függvény, ami már létezik. Hiszen minden további nélkül lehet egy <code>rnorm</code> nevű függvény definiálva egy csomagban! (Vagy akár két különböző csomagban.) A helyzet az, hogy ilyenkor, ha betöltjük a csomagot <code>library</code>-vel, akkor felülíródik a csomag függvényével a korábban már létező, ugyanolyan nevű függvény. Ha betöltünk később egy másik csomagot is <code>library</code>-vel, amiben van ugyanolyan nevű függvény, akkor meg azzal íródik felül. Az <code>rnorm</code> kicsit extrém példa, de mondjuk <code>filter</code> nevű függvény tényleg tömegével van különféle csomagokban. A dolog tehát egy olvashatósági problémát fog okozni: ha egyszerűen annyit látunk egy kódsorban, hogy <code>filter(x)</code>, akkor nem tudhatjuk, hogy ez <em>minek</em> a <code>filter</code>-je, melyik csomag <code>filter</code> nevű függvénye fog itt lefutni. A „beépített” <code>filter</code>? (Mert van ez is; igazából a <code>stats</code> csomagé.) A <code>dplyr</code> csomag <code>filter</code>-je? A <code>signal</code> csomag <code>filter</code>-je? A <code>seewave</code> csomag <code>filter</code>-je? A legrosszabb, hogy ezt nem is <em>lehet</em> megmondani pusztán ebből a kódsorból – mert azon fog múlni, hogy melyik csomagot töltöttük be utoljára! Tehát ezt csak úgy tudjuk eldönteni, ha visszamegyünk a kódban (akár több száz vagy ezer sort is adott esetben), megnézzük az <em>összes</em> <code>library</code> hívást, hogy definiál-e <code>filter</code>-t, és ez fogja eldönteni, hogy a kérdéses sorban pontosan mi is fut: a beépített <code>filter</code> vagy valamelyik csomagé? Ha több, <code>filter</code>-t definiáló csomagot is betöltünk <code>library</code>-vel, akkor még az is számítani fog, hogy milyen sorrendben töltjük be őket! Emiatt célszerűbb, ha ahol lehet, inkább a <code>::</code> operátort használjuk. Ennek az egyetlen hátránya<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>, hogy többet kell hozzá írni, és ha nagyon sokszor ismétlődik, az zavaró lehet, így végeredményben az ajánlás az, hogy <code>library</code>-vel <em>csak</em> azokat a csomagokat töltsük be, amik alapvetőek, amik függvényeit sokszor és intenzíven használjuk – a többi esetében jobb a <code>::</code> használata.</p>
<p>Egyetlen megjegyzés a végére: néha érdemes a csomagokat frissíteni! Hiszen a csomagok frissülnek a CRAN-en, ha a szerzőjük feltölt egy újabb változatot, de az nem kerül át automatikusan a gépünkre. Ezért érdemes rendszeresen megnyomni RStudio-ban a Tools / Update packages pontot, és az összes csomagot frissíteni. (Egyébként végeredményben ez is az <code>install.packages</code>-t fogja meghívni.)</p>
</section>
<section id="függvények-specifikációja-és-meghívása" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="függvények-specifikációja-és-meghívása"><span class="header-section-number">3.4</span> Függvények specifikációja és meghívása</h2>
<p>Függvény úgy hívható meg, hogy megadjuk a nevét, majd utána gömbölyű zárójelben az argumentumát, vagy argumentumait:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="dv">10</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  0.8077973 -0.7395581 -1.3033764  1.5051500 -1.5212452  0.8072057
 [7] -0.1743907  0.6295451  0.1042900  0.3781913</code></pre>
</div>
</div>
<p>Elképzelhető, hogy egy függvénynek egy argumentuma sincs, de a zárójelet ekkor is ki kell írni (azonnal becsukva, értelemszerűen). Ez fontos, ugyanis zárójel nélkül beírva a függvény nevét az R kiírja a függvény törzsét:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>rnorm</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (n, mean = 0, sd = 1) 
.Call(C_rnorm, n, mean, sd)
&lt;bytecode: 0x000002d581364b30&gt;
&lt;environment: namespace:stats&gt;</code></pre>
</div>
</div>
<p>Függvényről súgó a kérdőjellel kapható: <code>?rnorm</code>. Ez a megoldás akkor használható, ha a függvény pontos nevét tudjuk, mert azt kell a kérdőjel után írni, ha nem tudjuk a pontos nevet, csak a név egy töredékét, akkor a két kérdőjel (<code>??rno</code>) használható; ez végigkeresi az összes súgó-oldalt a beírt töredék után, és listát ad róluk<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>.</p>
<p>Ami nekünk most különösen fontos a súgóban, az a függvény ún. specifikációja. (Ha saját magunk írtuk a függvényt, akkor ezt a specifikációt mi magunk kellett hogy megadjuk – ahogy az az előző pontban szerepelt is.) Az <code>rnorm</code> esetén ez a következőképp néz ki:</p>
<p><code>rnorm(n, mean = 0, sd = 1)</code></p>
<p>Az argumentumok az <code>args</code> függvénnyel is megtudhatóak:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(rnorm)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (n, mean = 0, sd = 1) 
NULL</code></pre>
</div>
</div>
<p>Ebben a következő elemek láthatóak:</p>
<ul>
<li>A függvény neve, esetünkben az <code>rnorm</code>. Utána, ahogy már volt róla szó, gömbölyű zárójelben következnek az argumentumok.</li>
<li>Szintén volt róla szó, hogy az argumentumok száma tetszőleges lehet, a nullát is beleértve; jelen esetben a függvénynek három argumentuma van.</li>
<li>Minden argumentumnak van egy neve, kötelező is, hogy legyen. Ez esetben az első argumentum neve <code>n</code>, a másodiké <code>mean</code>, a harmadiké <code>sd</code>.</li>
<li>Egy argumentumnak lehet, de nem kötelező, hogy legyen ún. alapértelmezett értéke; ha van, akkor egyenlőségjel után szerepel az argumentum neve után. Esetünkben az <code>n</code> nevű argumentumnak nincs alapértelmezett értéke, a <code>mean</code>-nek és az <code>sd</code>-nek van, az előbbinek 0, az utóbbinak 1.</li>
</ul>
<p>Természetesen nagyon fontos, és a súgó többi részéből ez ki is derül, hogy egyáltalán mit csinál a függvény, mire jó, mi a tartalma az egyes argumentumoknak, mi a visszatérési értéke, de mi most fókuszáljunk a szintaktikára.</p>
<p>Kezdjük ott, hogy ha egy argumentumnak van alapértelmezett értéke, akkor azt az argumentumot nem kötelező megadni a hívás során, viszont aminek nincs, azt kötelező. Ezért van az, hogy az <code>rnorm(10)</code> lefut, noha csak egy argumentumot adtunk meg (mert a másik kettőnek van alapértelmezett értéke), viszont ha az <code>n</code>-et nem adjuk meg, akkor hibát ad a függvényhívás:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rnorm</span>()</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<pre><code>Error in rnorm(): argument "n" is missing, with no default</code></pre>
</div>
</div>
<p>Az alapértelmezett értékkel rendelkező argumentumokat tehát nem kötelező megadni, de természetesen lehet:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="at">n =</span> <span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">70</span>, <span class="at">sd =</span> <span class="dv">15</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 60.14018 58.53891 65.79888 95.67358 67.47220 68.61367 80.37803 77.35243
 [9] 85.48268 67.15689</code></pre>
</div>
</div>
<p>Mint látható, argumentumot úgy adunk meg a hívás során, hogy beírjuk a nevét, egyenlőségjelet teszünk<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, majd utána leírjuk az értékét. Ami fontos, hogy a nevek elhagyhatóak, ez esetben az R abban a sorrendben rendeli hozzá a beírt értékeket az argumentumokhoz, amilyen sorrendben a specifikációban szerepelnek<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>. Vagyis a fenti hívás egyenértékű ezzel:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="dv">10</span>, <span class="dv">70</span>, <span class="dv">15</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  54.42389  72.05972  76.68758  72.53190  68.67819  86.34203 103.00223
 [8]  72.14209  73.69577  76.64817</code></pre>
</div>
</div>
<p>Ezt voltaképp már korábban is láttuk: az <code>rnorm(10)</code> ezért működött minden név megadása nélkül is.</p>
<p>A nevek megadása lehetővé teszi, hogy más sorrendben soroljunk fel argumentumokat, mint a specifikációban szerepelnek:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="at">sd =</span> <span class="dv">15</span>, <span class="at">n =</span> <span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">70</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 43.61151 55.22002 59.77514 62.53416 86.69338 46.77563 73.65187 83.89362
 [9] 68.23847 56.75238</code></pre>
</div>
</div>
<p>Vagy, hogy átugorjunk egy argumentumot:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="dv">10</span>, <span class="at">sd =</span> <span class="dv">15</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  -7.440627 -29.611329   1.659362  -2.727111  -7.168572  -8.868446
 [7]  -3.460286  -9.183961   2.449413   5.389557</code></pre>
</div>
</div>
<p>Az R-es gyakorlat az, hogy az első néhány, mondjuk 3-4 argumentumtól eltekintve <em>akkor is</em> írjuk ki a neveket, ha egyébként sorrendben adtuk meg őket a hívás során. Ennek nem a kód futtathatóságához, hanem az olvashatóságához van köze: átlagos R-hez értő embertől elvárható, hogy – különösen a gyakran használt függvényeknél – az első néhány argumentumról tudja, hogy mi a jelentésük, de a továbbiakról már nem feltétlenül, így az olvasónak segítség, ha ezeknél feltüntetjük a nevet, még akkor is, ha az R-nek nem kellene, mert sorrendben jönnek. Ez azért van így, mert ezek általában beszélő nevek (ez az <code>rnorm</code> példáján is jól látszik!); ha majd mi magunk definiálunk függvényt, akkor is törekedjünk rá emiatt, hogy mi is ilyen beszélő neveket adjunk.</p>
<p>Egy utolsó dolgot kell még a fentiek kapcsán megbeszélnünk. Az eddigi leírásból úgy tűnhet, hogy a függvényeknek mindig adott, rögzített, előre ismert számú argumentumuk van – annyi, amennyit a specifikációban felsoroltunk. Az eddigi példákban ez valóban így volt, de gondoljunk bele, mi a helyzet mondjuk a <code>c</code>-vel? (Eddig nem mondtam, de természetesen ez is egy függvény!) Hogyan lehetséges, hogy működik a <code>c(1, 2)</code> és a <code>c(1, 2, 3)</code> is? A válasz az, hogy az R megenged egy speciális argumentumot, a három pontot<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>: a <code>c</code> függvény specifikációja úgy néz ki, hogy <code>c(...)</code>. A három pont azt jelenti: tetszőleges számú argumentum. Ilyen esetben tehát azt mondjuk, hogy mi magunk sem tudjuk, hogy hány argumentumot kapunk, minden teljesen azon múlik, hogy a felhasználó hogyan hívja meg a függvényt – ami szerepel a meghívásban, az fog átkerülni a <code>...</code> alatt, legyen az 0 argumentum, 1, vagy 100. A felhasználó megteheti, hogy a <code>...</code> helyén 0 argumentumot ír be a függvény meghívásakor, megteheti, hogy 1-et, megteheti, hogy 100-at. (Ha majd saját függvény írunk: ilyenkor a függvényen belül szintén <code>...</code> névvel hivatkozhatunk arra, hogy mit kaptunk a hívás során. Annyit kell tudni erről, hogy ez egy elég speciális elem, első lépésben szinte mindig listává alakítjuk: <code>list(...)</code> már egy szokásos lista lesz, amit innentől a hagyományos módon, megszokott listaként használhatunk.) A <code>...</code>-ban átadott argumentumoknak lehet neve, de ez nem kötelező. A <code>...</code> vegyíthető a „szokásos” argumentumokkal: egy függvénynek nézhet úgy ki a specifikációja, hogy <code>f(x, ..., y = 1, z = 2)</code>. Ez azt jelenti, hogy az első egy kötelező argumentum, <code>x</code> névvel, utána jön tetszőleges, és előre nem ismert számú argumentum (akár 0 is): hogy itt mit kap a függvény, az teljesen azon múlik, hogy a felhasználó hogyan hívja meg. Ezután egy <code>y</code> nevű argumentum következik 1 alapértelmezett értékkel, végül egy <code>z</code> nevű 2 alapértelmezett értékkel. Ennek megfelelően az <code>f(1)</code> esetén az <code>x</code> értéke 1 lesz, a <code>list(...)</code> egy üres lista, <code>y</code> pedig 1 , míg <code>z</code> értéke 2. Az <code>f(1, z = 10)</code> annyiban tér el ettől, hogy <code>z</code> értéke 10 lesz. Végezetül az <code>f(1, 2, a = 3, 4, z = 10)</code> hívásnál <code>x</code> értéke 1 lesz, a <code>list(...)</code> egy háromelemű lista lesz 2, 3 és 4 értékekkel (amiből a középsőnek <code>a</code> a neve, a másik kettőnek nincs neve), <code>y</code> értéke 1, <code>z</code> értéke 10. (Mint látható, ilyenkor, ha <code>y</code>-nak vagy <code>z</code>-nek szeretnénk beállítani az értékét, akkor kötelező megadni a nevét a hívásban, különben az R azt hinné, hogy a megadott argumentum a <code>...</code> része.)</p>
<p>Zárásként még egy apróság: bizonyos esetekben felmerül a kérdés, hogy mi a teendő akkor, ha úgy kell egy függvényt meghívnunk, hogy mi magunk sem tudjuk előre (tehát a programkód írásakor) az argumentumait, például mert egy másik függvény állítja elő. Ilyenkor célszerű ezeket egy listába helyezni, az R ugyanis kínál egy megoldási lehetőséget erre:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>fuggvenyargs <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">n =</span> <span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">70</span>, <span class="at">sd =</span> <span class="dv">15</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">do.call</span>(rnorm, fuggvenyargs)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  78.59756 101.04023  35.82199  83.66425  46.90125  33.82341  87.76873
 [8]  72.74925  87.31580  61.37659</code></pre>
</div>
</div>
<p>A <code>do.call</code> tehát meghívja az első argumentumban megadott függvényt a második argumentumban megadott argumentumokkal. A <code>do.call</code> lényegében elválasztja egymástól a függvény nevét és argumentumait (ami az <code>rnorm(sd = 15, n = 10, mean = 70)</code> típusú hívásnál össze van gubancolódva); ezzel megoldást adva a fentiekben említett helyzetre is. Ha a függvény argumentumai között <code>...</code> van, a <code>do.call</code> akkor is működik, vagyis az átadott lista hossza nem kötelező, hogy mindig ugyanaz legyen.</p>
</section>
<section id="az-r-ben-minden-utasítás-függvényhívás" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="az-r-ben-minden-utasítás-függvényhívás"><span class="header-section-number">3.5</span> Az R-ben minden utasítás függvényhívás</h2>
<p>Érdemes még egy dologról beszélni, ami látszólag egy erősen technikai aspektus, de valójában fontos következményei vannak: arról, hogy az R-ben minden utasítás igazából függvényhívás.</p>
<p>Ennek első ránézésre pár dolog ellentmond; nézzük most meg ezeket közelebbről. Kezdjük kapásból ezzel:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="sc">+</span> <span class="dv">2</span></span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3</code></pre>
</div>
</div>
<p>Ez hogy lenne már függvényhívás?! Nincs is benne függvénynév, pláne nincs gömbölyű zárójel, meg argumentumok…! – mondhatná valaki. Azonban a helyzet az, hogy de, van benne függvénynév, a <code>+</code>. Ez igenis egy függvény neve, nyugodtan leírhatjuk szokásos formában is, egyedül arra kell figyelni, hogy a <code>+</code> karakter nem felel meg a változónevekre vonatkozó, korábban látott szabályoknak – úgynevezett nem szintaktikus név – ezért a szokásos formájú hívásnál backtick-ek közé kell tenni:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="st">`</span><span class="at">+</span><span class="st">`</span>(<span class="dv">1</span>, <span class="dv">2</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3</code></pre>
</div>
</div>
<p>Egyszerűen arról van szó, hogy az R ad nekünk annyi segítséget, hogy megengedi, hogy a zárójelet nem kell kitenni, de ami még fontosabb, hogy lehetővé teszi, hogy ilyen, úgynevezett operátorok a szokásos módon, az argumentumok között szerepeljenek. (Ezt hívják amúgy a programozáselméletben infix jelölésnek, míg a második, „szokásos függvényhívás” formát prefix jelölésnek.)</p>
<p>Mi a helyzet az értékadással? Mondjuk:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>x</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5</code></pre>
</div>
</div>
<p>Itt már talán nem okozok meglepetést: egyszerűen arról van szó, hogy a <code>&lt;-</code> az igazából egy függvény. Úgyhogy igen, bármilyen meglepő, de a fenti igazából ezzel egyenértékű:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="st">`</span><span class="at">&lt;-</span><span class="st">`</span>(x, <span class="dv">10</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>x</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
</div>
<p>Az egyetlen, ami fontos, hogy ez egy mellékhatásos függvény, ahol a mellékhatás az, hogy a memóriában valami elhelyeződik.</p>
<p>A végére hagytam a talán legfontosabb példát. Mi a helyzet azzal, amit eddig úgy hívtunk, hogy „kiíratjuk egy változó értékét”? Például:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>x</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
</div>
<p>Na itt aztán végképp nincsen semmilyen függvényhívás…! – mondhatná valaki. De! Nagyon is van, a helyzet ugyanis az, hogy az R, miután végzett a kiértékelésekkel, az eredményre automatikusan meghívja a <code>print</code> függvényt. (Meglepő lehet, hogy kiértékelést említettem – mit kell abban kiértékelni, hogy <code>x</code>? – és ez valóban egyértelműbb lenne, ha azt írtam volna, hogy <code>exp(x)</code>, de valójában az <code>x</code> is kiértékelhető, egyszerűen azzal a szabállyal, hogy egy változó kiértékeltje saját maga.) A fenti tehát igazából ezt jelenti:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(x)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
</div>
<p>A <code>print</code> pedig egy mellékhatásos függvény, ahol a mellékhatás az, hogy az eredmény megjelenik a konzolon.</p>
<p>(Zárójel: tehát az <code>1 + 2</code> az nem csak <code>`+`(1, 2)</code> valójában, hanem <code>print(`+`(1, 2))</code>…!)</p>
<p>A dolog azért fontos, mert az R-ben van egy viselkedés, ami csak a fentiek ismeretében érthető meg. Töltsük be a példa-adatbázisunkat, és hajtsunk végre egy egyszerű statisztikai próbát:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(birthwt, <span class="at">package =</span> <span class="st">"MASS"</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="fu">t.test</span>(bwt <span class="sc">~</span> smoke, <span class="at">data =</span> birthwt)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Welch Two Sample t-test

data:  bwt by smoke
t = 2.7299, df = 170.1, p-value = 0.007003
alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0
95 percent confidence interval:
  78.57486 488.97860
sample estimates:
mean in group 0 mean in group 1 
       3055.696        2771.919 </code></pre>
</div>
</div>
<p>Hogy mi ez a próba, az most teljesen mindegy is (<span class="math inline">\(t\)</span>-próbával vizsgáljuk, hogy a dohányzó és a nem-dohányzó anyukák újszülttjeinek várható születési tömege szignifikánsan eltér-e), a fontos, hogy valamilyen komplexebb statisztikai elemzés. Mit látunk? Egy szép, ízlésesen elrendezett eredményt, benne a legfontosabb számokkal, sőt, még némi magyarázó szöveggel is kiegészítve. Ami most lényeges: úgy tűnik, hogy működik a szabály, hogy „ha nincs nyíl, akkor kiíratunk, de nem mentünk”: a kiíratás valóban megjelent, és új változó valóban ne jött létre. Ellenőrizzük le a fordított irányt:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>teszteredmeny <span class="ot">&lt;-</span> <span class="fu">t.test</span>(bwt <span class="sc">~</span> smoke, <span class="at">data =</span> birthwt)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Továbbra is stimmel minden: most nem íratódott ki semmi, de létrejött az új változó. Ahogy vártuk! Most nézzük meg, mi van a változóban:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>teszteredmeny</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Welch Two Sample t-test

data:  bwt by smoke
t = 2.7299, df = 170.1, p-value = 0.007003
alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0
95 percent confidence interval:
  78.57486 488.97860
sample estimates:
mean in group 0 mean in group 1 
       3055.696        2771.919 </code></pre>
</div>
</div>
<p>Ez is pontosan megfelel a várakozásunknak: az van benne, amit korábban a kiíratásnál kaptunk. Mi más lenne? Nos, nézzük kicsit meg közelebbről ezt a változót:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(teszteredmeny)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>List of 10
 $ statistic  : Named num 2.73
  ..- attr(*, "names")= chr "t"
 $ parameter  : Named num 170
  ..- attr(*, "names")= chr "df"
 $ p.value    : num 0.007
 $ conf.int   : num [1:2] 78.6 489
  ..- attr(*, "conf.level")= num 0.95
 $ estimate   : Named num [1:2] 3056 2772
  ..- attr(*, "names")= chr [1:2] "mean in group 0" "mean in group 1"
 $ null.value : Named num 0
  ..- attr(*, "names")= chr "difference in means between group 0 and group 1"
 $ stderr     : num 104
 $ alternative: chr "two.sided"
 $ method     : chr "Welch Two Sample t-test"
 $ data.name  : chr "bwt by smoke"
 - attr(*, "class")= chr "htest"</code></pre>
</div>
</div>
<p>És akkor itt jön a meglepetés: ez a változó valójában egy 10 elemű lista…! De akkor hogyan lett a kiíratásakor ebből egy ilyen szöveg?! (A kiírt dolgok egy része, például ezek a magyarázó szövegek még csak benne sincsenek a változóban!) Hogy jelenhetett akkor ez meg a kiíratáskor?</p>
<p>A válasz a fenti output utolsó sorában rejlik. Amit itt látunk, hogy van egy <code>class</code> nevű attribútuma a változónak, ami <code>htest</code> értékre van beállítva. Mint tudjuk, bármilyen nevű attribútumot definiálhatunk egy változóhoz, de a <code>class</code> különlegesen viselkedik. A részletek megtárgyalása nélkül: valójában nem egyetlen <code>print</code> függvény van, hanem több tucatnyi, és az R-ben van egy belső mechanizmus, ami az alapján választja ki, hogy pontosan melyik fut le, hogy mi a kiíratott változó <code>class</code>-a. Ha <code>htest</code>, akkor igazából a <code>print.htest</code> fog lefutni<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>. Ez pedig így néz ki (figyeljük meg, hogy a <code>:::</code> operátort kell használnunk, mert ez a függvény ugyan benne van az – automatikusan betöltődő – <code>stats</code> csomagban, de nem exportált függvény, ami logikus is, mert kívülről direkte nem kell meghívnunk):</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>stats<span class="sc">:::</span>print.htest</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (x, digits = getOption("digits"), prefix = "\t", ...) 
{
    cat("\n")
    cat(strwrap(x$method, prefix = prefix), sep = "\n")
    cat("\n")
    cat("data:  ", x$data.name, "\n", sep = "")
    out &lt;- character()
    if (!is.null(x$statistic)) 
        out &lt;- c(out, paste(names(x$statistic), "=", format(x$statistic, 
            digits = max(1L, digits - 2L))))
    if (!is.null(x$parameter)) 
        out &lt;- c(out, paste(names(x$parameter), "=", format(x$parameter, 
            digits = max(1L, digits - 2L))))
    if (!is.null(x$p.value)) {
        fp &lt;- format.pval(x$p.value, digits = max(1L, digits - 
            3L))
        out &lt;- c(out, paste("p-value", if (startsWith(fp, "&lt;")) fp else paste("=", 
            fp)))
    }
    cat(strwrap(paste(out, collapse = ", ")), sep = "\n")
    if (!is.null(x$alternative)) {
        cat("alternative hypothesis: ")
        if (!is.null(x$null.value)) {
            if (length(x$null.value) == 1L) {
                alt.char &lt;- switch(x$alternative, two.sided = "not equal to", 
                  less = "less than", greater = "greater than")
                cat("true ", names(x$null.value), " is ", alt.char, 
                  " ", x$null.value, "\n", sep = "")
            }
            else {
                cat(x$alternative, "\nnull values:\n", sep = "")
                print(x$null.value, digits = digits, ...)
            }
        }
        else cat(x$alternative, "\n", sep = "")
    }
    if (!is.null(x$conf.int)) {
        cat(format(100 * attr(x$conf.int, "conf.level")), " percent confidence interval:\n", 
            " ", paste(format(x$conf.int[1:2], digits = digits), 
                collapse = " "), "\n", sep = "")
    }
    if (!is.null(x$estimate)) {
        cat("sample estimates:\n")
        print(x$estimate, digits = digits, ...)
    }
    cat("\n")
    invisible(x)
}
&lt;bytecode: 0x000002d58120a880&gt;
&lt;environment: namespace:stats&gt;</code></pre>
</div>
</div>
<p>Nem fontos, hogy a fenti kód minden egyes részét pontosan értsük, a fontos az összkép: <em>ez</em> tartalmazza a szép, ízléses, magyarázott kiíratás sémáját! Ebben van benne az elrendezés, az összekötő szövegek stb., természetesen úgy, hogy a dolog hivatkozik a kiírandó változó megfelelő számaira – amik ugyebár a lista egyes elemei. Fix szövegként kiírja, úgy sorba, hogy „sample estimates”, azaz a becslések a mintából, utána pedig jön az <code>x$estimate</code>, vagyis, hogy „vedd ki az <code>x</code>-ből – ami a kiírandó változó – az <code>estimate</code> nevű elemet”. És menjünk vissza, nézzük meg: valóban az lesz a lista <code>estimate</code> nevű elemében, ami megjelenik a „sample estimates” után! A (megfelelő) <code>print</code> tartalmazza a sémát, a konkrét számok pedig kitöltődnek a ki-<code>print</code>-elt változóból, mint listából.</p>
<p>Egyébként kipróbálhatjuk, hogy ha rákényszerítjük, hogy ne a testreszabott, hanem az alapértelmezett <code>print</code> függvényt használja az R a kiíratáshoz, akkor valóban úgy kapjuk meg a <code>teszteredmeny</code> változó tartalmát, mint egy szokásos lista:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print.default</span>(teszteredmeny)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>$statistic
       t 
2.729886 

$parameter
      df 
170.1002 

$p.value
[1] 0.007002548

$conf.int
[1]  78.57486 488.97860
attr(,"conf.level")
[1] 0.95

$estimate
mean in group 0 mean in group 1 
       3055.696        2771.919 

$null.value
difference in means between group 0 and group 1 
                                              0 

$stderr
[1] 103.9519

$alternative
[1] "two.sided"

$method
[1] "Welch Two Sample t-test"

$data.name
[1] "bwt by smoke"

attr(,"class")
[1] "htest"</code></pre>
</div>
</div>
<p>Így már jobban érthető a listák jelentősége is, amit a korábbi fejezetben nem tudtam pontosan elmondani: a listák rengetegszer előfordulnak – akkor is, amikor mi nem látjuk! Hiszen ebben a <span class="math inline">\(t\)</span>-próbás példában sehol nem bukkantak fel explicite listák, nem kellett listát kezelnünk, azt sem kellett tudnunk, hogy mi az, hogy lista – de a háttérben nagyon is volt szerepük, listák mozogtak a különböző függvények között. A kicsit is komplexebb statisztikai számítások nagyon gyakran listát adnak vissza (még ha ezt mi nem is látjuk), ami teljesen logikus ha meggondoljuk, hiszen tipikus, hogy ezek különböző típusú adatokat tartalmaznak. Ez így van a <span class="math inline">\(t\)</span>-próbás példában is, ahol előfordul szám, szöveg, egyelemű és többelemű vektor. Az ilyenek tárolására pont a lista a megfelelő adatszerkezet.</p>
<p>A <code>class</code>-t természetesen mi magunk is kihasználhatjuk a saját függvényeinkben. A fentiek ugyanis azt jelentik, hogy ha beállítunk egy <code>class</code>-t a függvényünk által visszaadott listára <em>és</em> definiálunk egy <code>print</code>-et arra a <code>class</code>-ra, akkor a függvényünk eredménye rögtön szépen megformázva fog megjelenni – anélkül, hogy a felhasználónak bármit tennie kellett volna (vagy akár csak tudna erről az egészről)!</p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Az R a paramétert formális argumentumnak hívja; ezt a szóhasználatot egyébként a magyar szaknyelv is megengedi mint a paraméter szinonimája. De sokszor nem vesződnek ezzel a különbségtétellel, és egyszerűen argumentumot mondanak.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Az alternatívája a cím szerinti paraméterátadás, ami nagyon leegyszerűsítve az, ha a függvény nem a változó egy másolatát kapja meg, hanem azt a memóriacímet, ahol a változó van. Ez más, mert bár kiolvasva a memóriacímet megkapjuk a változó tartalmát, ugyanúgy mint az érték szerinti átadásnál, viszont a memóriacím ismeretében akár módosíthatjuk is azt: ha valamit átírunk ott, az módosítja a hívó program számára is a változót. Cím szerinti átadáshoz hasonló mechanizmus megvalósítható R-ben is, de külön erőfeszítést igényel, az alapvető működési mód az R-ben az érték szerinti átadás. A valóságban az érték és cím szerinti átadásnak sok egyéb finomsága van, más paraméterátadási módok is léteznek, de ezek számunkra nem lesznek most fontosak.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Ezt hívják copy-on-modify mechanizmusnak, ez szabályozza, hogy mikor készül másolat, és ha nem készül, akkor hogyan oldja meg a paraméterátadást.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>És az érték szerinti paraméterátadás miatt argumentumot sem használhatunk információ visszajuttatására, ahogy az más nyelvben előfordulhatna.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Ezen a ponton visszatérhetünk egy pillanatra arra a korábbi megállapításra, hogy egy függvény lecserélhető a visszatérési értékére. Ha ez megvalósul, akkor azt mondjuk, hogy fennáll a hivatkozási átlátszóság; ennek a feltétele, hogy a függvény mellékhatásmentes legyen, <em>és</em> adott argumentumokra mindig, determinisztikusan ugyanazt a visszatérési értéket szolgáltassa. Az ilyeneket tiszta függvénynek szokták hívni a programozáselméletben.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Legegyszerűbb esetben használhatjuk a <code>stopifnot</code> függvényt, de van külön csomag is erre a célra, például az <code>assertthat</code> vagy a <code>checkmate</code>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>A <code>base</code>, a <code>stats</code>, a <code>methods</code>, a <code>graphics</code>, a <code>grDevices</code>, a <code>utils</code> és a <code>datasets</code>. Egész pontosan az a mechanizmus, hogy a <code>base</code> csomag mindenképp betöltődik induláskor, utána pedig azok töltődnek még be ezen felül automatikusan, amik a <code>defaultPackages</code> nevű opcióban szereplnek; az előbbi lista ennek az alapértelmezését tükrözi.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Az R szokásos installációja a korábban említett, induláskor automatikusan betöltődő csomagokon kívül még kb. egy tucatnyi csomagot telepít, tehát ezeket be kell ugyan kézzel tölteni, de külön telepíteni nem kell. Ezen kívül minden más csomagot először telepíteni kell.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Egyetlen megjegyzés ehhez. A CRAN-en a csomagok fent vannak forráskóddal, illetve Windows-ra előre lefordított (binary) verzióban is. Ez azt jelenti, hogy Linux-on a CRAN-ről történő telepítés mindenképp a forráskód fordítását fogja jelenteni, Windows-on viszont nem feltétlenül. Néha azonban az a helyzet, hogy a forráskódú verzió frissebb, mint a lefordított; ilyenkor a Windows-on is jól jöhet a forráskódból fordítás. Ehhez azonban fordítóeszköz fog kelleni! Szerencsére ehhez van kész eszköztár az R-hez, a neve <a href="https://cran.r-project.org/bin/windows/Rtools/">RTools</a>, érdemes telepíteni.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Ennek van egy alternatívája, a <code>require</code> függvény. A kettő nagyon hasonlít egymásra, az egyetlen különbség akkor bukik ki, ha nem telepített könyvtárat akarunk betölteni: ekkor a <code>library</code> hibát ad, a <code>require</code> csak figyelmeztetést, és visszatérési értékként <code>FALSE</code>-ot (sikeres betöltés esetén ezzel szemben <code>TRUE</code>-t). Ebből következik, hogy interaktív munkamenetnél – magyarán, ha kézzel pötyögünk, meg hajtatunk végre kódsorokat – a <code>library</code> tökéletes, viszont ha csomag-betöltést egy futó program maga végzi, akkor a <code>require</code> jobb lehet, mert gépi úton tudjuk kezelni a helyzetet, hogy volt-e az adott gépen telepítve a csomag, sikerült-e betölteni, és ennek fényében továbbmenni. De vigyázat: ha ezt a kezelést nem hajtjuk végre, akkor a <code>require</code> veszélyes lehet, mert azt okozhatja, hogy a futás nem áll meg azonnal, és csak később – praktikusan amikor az adott könyvtárból akarunk egy függvényt hívni – lesz baj, amit viszont így nehezebb lesz beazonosítani, hogy mi okoz. Mivel azonban egy csomag elérhetőségének az ellenőrzésére van más megoldás, a <code>requireNamespace</code> függvény, így van, aki azt javasolja, hogy <code>require</code>-t egyáltalán ne használjunk.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Elvileg egy nagyon minimális teljesítmény-veszteséget jelent a <code>::</code> (mivel a háttérben egy függvényhívást jelent igazából), de ennek a legtöbb gyakorlati esetben nem lesz érdemi jelentősége: én most tettem egy próbát, az <code>actuar::rinvexp(10)</code> medián futásideje a gépemen 1,9 <span class="math inline">\(\mu\)</span>s, az <code>actuar</code> csomag <code>library</code>-vel betöltése után az <code>rinvexp(10)</code>-é 1,6 <span class="math inline">\(\mu\)</span>s. A különbség 300 ns, azaz ha egymillió alkalommal használjuk a <code>::</code> operátort egy kódban, az összesen 0,3 másodperc veszteséget fog jelenteni… Egy fokkal talán nyomósabb érv lehet a <code>library</code> mellett, hogy ha a szkriptünket azzal kezdjük, hogy az összes használt csomagot be-<code>library</code>-zzük, akkor egyrészt azonnal látszik, hogy mikre lesz szükség, másrészt, ha valamelyik nincs meg a futtató felhasználó gépén, akkor az rögtön az elején kiderül a hibából. A <code>library</code>-k használata nélkül ez csak az első <code>::</code>-nál bukna ki, ami nem elegáns: általános programtervezési elv, hogy ha valami baj van, akkor jobb, ha az minél előbb kiderül.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Ez a helyi gépen keres, ebből fakadóan természetesen csak azokat a csomagokat tudja végigkeresni, amik telepítve vannak helyileg. Létezik három kérdőjeles változat (<code>???rno</code>) is, ami az R központi weboldalán keres, így – többek között – valamennyi csomagot végignézi, függetlenül attól, hogy helyileg telepítve van-e. Ez azonban egy külön csomag, az <code>sos</code> telepítését igényli (a három kérdőjel ugyanis igazából nem más, mint egy hozzárendelt rövidítés, ún. alias az <code>sos::findFn</code> függvényhez, ami ilyen keresést hajt végre).<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Az értékadásnál említettem, hogy a nyíl helyett szinte felcserélhetően használhatnánk egyenlőségjelet is, és hozzátettem, hogy az R-es szokás az, hogy az egyenlőségjelet másra használjuk. Akkor most már elárulhatom: erre! A szokás az, hogy az értékadásnál nyilat írunk, függvény argumentumának megadásakor egyenlőségjelet. A kettő között a különbség <a href="https://stackoverflow.com/a/1742550/3915051">minimális</a>.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>Hogy teljesen precíz legyek, az algoritmus a következő: először fogja az elnevezett argumentumokat, és megkeresi, hogy <em>pontosan</em> olyan névvel van-e paraméter, ha igen, akkor megfelelti őket egymásnak. Ha marad még hívásban szereplő argumentum, aminek nem feleltetett meg paramétert, akkor tovább megy: ezt követően – és ez meglepő lehet – részleges egyezéseket is keres az elnevezett argumentumok között: megnézi, hogy van-e olyan, ahol a hívásban szereplő név egyezik a paraméter nevének az <em>elejével</em>. Például ha a hívásban <code>atl</code> néven hivatkozunk egy argumentumra az át fog adódni az <code>atlag</code> paraméternek (feltéve, hogy nem adtunk át <code>atlag</code> nevű argumentumot is, mert az az első lépésben már „megenné” az <code>atlag</code> nevű paramétert). Végezetül, ha még így is van nem összerendelt argumentum és paraméter, akkor az összes megmaradt argumentumot sorrendben osztja ki a megmaradt paramétereknek.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>Angolul a neve ellipsis; semmi köze az ellipszishez, egyszerűen arról van szó, hogy angolul, mármint a nyelvészetben, így hívják a – tipikusan mondat végi – három pontot. Az R nemes egyszerűséggel „dot-dot-dot”-nak is hívja.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>A <code>print</code>-nek természetesen van egy alapértelmezett variánsa is, a <code>print.default</code>, ez fut akkor, ha nincs <code>class</code>, vagy az adott <code>class</code>-hoz nincs külön definiált <code>print</code>.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kimásolva!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kimásolva!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/ferenci-tamas\.github\.io\/r-nyelv");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./adattipusokadatszerkezetek.html" class="pagination-link" aria-label="Adattípusok, adatszerkezetek">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Adattípusok, adatszerkezetek</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./programozas.html" class="pagination-link" aria-label="Az R programozása">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Az R programozása</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/ferenci-tamas/r-nyelv/edit/main/fuggvenyek.qmd" class="toc-action"><i class="bi bi-github"></i>Az oldal szerkesztése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/blob/main/fuggvenyek.qmd" class="toc-action"><i class="bi empty"></i>Forráskód megtekintése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/issues/new" class="toc-action"><i class="bi empty"></i>Észrevétel jelzése</a></li></ul></div></div></div></footer><script type="text/javascript">
var sc_project=12422840; 
var sc_invisible=1; 
var sc_security="d32cce24"; 
</script>
<script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
<noscript><div class="statcounter"><a title="ingyenes
webstatisztika" href="https://www.statcounter.hu/" target="_blank"><img class="statcounter" src="https://c.statcounter.com/12422840/0/d32cce24/1/" alt="ingyenes webstatisztika" referrerpolicy="no-referrer-when-downgrade"></a></div></noscript>




</body></html>