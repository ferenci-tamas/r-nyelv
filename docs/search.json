[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bevezetés az R nyelv és statisztikai számítási környezet használatába",
    "section": "",
    "text": "Előszó\nAz R egy ingyenes, nyílt forráskódú, rendkívüli tudású és folyamatosan fejlődő programozási nyelv illetve statisztikai számítási környezet, mely kiválóan alkalmas a legkülönfélébb statisztikai és adattudományi feladatok megoldására.\nAz R egyik fontos jellemzője, hogy lényegében minden feladat elvégzéshez egy szkriptet kell írnunk – szemben más statisztikai programokkal1, ahol csak egy grafikus felületen kell kattintgatnunk. Ez elsőre ijesztőnek hangozhat, és csakugyan igaz, hogy más programokhoz képest a tanulási görbe meredekebben indul, hiszen a kattintgatással szemben itt már két szám átlagolásához is programot kell írni. A dolog azonban kifizetődő: lehet, hogy egyszerű dolgokat más statisztikai környezetekben könnyebb végrehajtani, itt meg bonyolultabb, de cserében itt a bonyolultabbakat sem sokkal nehezebb, míg más statisztikai programokban az, vagy egyenesen lehetetlen. Kicsit is komolyabb elemzések, kutatások végzésekor az R megtanulásába befektettt munka hamar – és pláne: busásan – megtérül.\nA fentiekből már érthető, hogy ahhoz, hogy el tudjunk kezdeni statisztikai elemzéseket végezni R-ben, először az R-rel mint programozási nyelvvel kell megismerkedni. Nagyon fontos hangsúlyozni, hogy ez a jegyzet kizárólag az R nyelvi kérdéseivel és programozásával foglalkozik, az R statisztikai célokra történő felhasználása egy másik jegyzetem (Ferenci Tamás: Bevezetés a biostatisztikába) témája.\nAz R talán legnagyobb erejét a hozzá megírt, megszámlálhatatlan sok2 kiegészítő csomag adja, amikkel jószerével minden elképzelhető (és számos nehezen elképzelhető…) statisztikai feladat, adott esetben rendkívül bonyolultak is megoldhatóak, sokszor mindössze egy-egy függvényhívással. Számos kitűnő, jól dokumentált kiegészítő csomag érhető el (melyek maguk is ingyenesek és nyílt forráskódúak); nagyon tipikus, hogy a vadonatúj statisztikai módszereket is R-ben implementálják első közlésükkor. Az R csomagok központi repozitóriuma CRAN (Comprehensive R Archive Network).\nMindezek alapja az R mögött álló, rendkívül széles és erős nemzetközi közösség. Ingyenes programként bárki számára elérhető, nyílt forráskódú programként pedig jól bővíthető, illetve ez sokaknak a tudományra vonatkozó általános filozófiájával – „open science”, nyílt tudomány – is találkozik (így az enyémmel is). Számos statisztikus fejleszt R alá csomagokat, általában nagyon segítőkészek mind az esetleges hibák javításában, mind az új funkciók megvalósítására vonatkozóan. Több fórum érhető el (pl. a Stackoverflow), ahol a kezdőszintű egyszerű problémáktól a legspeciálisabb nehézségekig mindenben segítséget lehet kérni (és nem ritka, hogy a legnevesebb R fejlesztők válaszolnak!). Nagyon sok csomag jelen van a Github-on is, ami szintén kiváló platform az eszmecserére.\nProgramozási nyelvek „népszerűségét” nem könnyű objektíven lemérni (egyáltalán, definiálni), de azért van pár ezzel kapcsolatos vizsgálat, illetve folyamatosan frissülő mérőszám3. A talán legismertebb TIOBE-index szerint az R 2025 őszén a 13. legnépszerűbb nyelv, a RedMonk 2025. eleji kimutatása szerint a 12. legnépszerűbb, az IEEE Top Programming Languages 2025-ös kiadása szerint a 11. legnépszerűbb. Vegyük figyelembe, hogy a mezőny általános célú nyelveket is tartalmaz, míg az R elég speciális alkalmazási területű.\nAz R különösen erős az eredmények kommunikálásban. Kiegészítő csomagokkal könnyedén lehetséges ún. dinamikus dokumentumok készítése, melyek együtt tartalmazzák a kódokat, és a kapcsolódó leírást.\nA reprodukálható kutatás jegyében a cikkekkel együtt közzétett elemzések is nagyon gyakran R-ben íródtak, ezekből szintén sok ötlet meríthető.",
    "crumbs": [
      "Előszó"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Bevezetés az R nyelv és statisztikai számítási környezet használatába",
    "section": "",
    "text": "Megjegyzendő, hogy az R-hez is létezik ilyen grafikus felület, az R Commander, azonban használata komolyabb elemzési feladatok elvégzéséhez nem szükséges, illetve nem hasznos, kezdők számára azonban jó bevezető eszköz lehet, mivel a jól ismert statisztikai programokhoz teljesen hasonló grafikus felülettel ruházza fel az R-et.↩︎\n2025 őszén már több mint 22 ezer! Ez szó szerint napról-napra nő.↩︎\nKülön kérdés, hogy a mostani érában mennyi értelme lesz egyáltalán az ilyen indexeknek, ezt egyre több írás pedzegeti.↩︎",
    "crumbs": [
      "Előszó"
    ]
  },
  {
    "objectID": "rbevezetes.html",
    "href": "rbevezetes.html",
    "title": "1  R szkriptek és az RStudio",
    "section": "",
    "text": "Egy R-ben írt program, gyakrabban használt nevén szkript, R-beli utasítások sorozata. Lehet egyetlen sor, mely két számot átlagol, vagy több ezer utasításból felépülő komplex elemzés. Az R interpretált nyelv, nem fordított, ami azt jelenti, hogy nem a szkript egészét, egyben fordítja le számítógép által végrehajtható kóddá az R, hanem az utasításokat egyesével hajtja végre, utasításról utasításra.\nAz RStudio fejlesztői környezet alapbeállításában a bal oldali rész alján látható a konzol, ahol közvetlenül beküldhetünk utasításokat az R-nek, illetve az – akár közvetlenül, akár a lent vázolt módon szkriptből – beküldött utasítások eredményei láthatóak. A konzol felett találjuk a megnyitott szkriptet, vagy szkripteket. Új szkriptet megnyitni (vagy az elsőt megnyitni, ha még egy sincs nyitva – ez esetben a konzol az egész bal oldalt elfoglalja) a Ctrl-Shift-NCtrl-Shift-N billentyűkombinációval, vagy az ikonsor bal szélső ikonjára (fehér lap zöld plusz-jellel) kattintva, és ott az R Script pontot választva lehet.\nA konzolba írt utasítások azonnal végrehajtódnak (amint Enter-t ütünk, és ezzel beküldjük az utasítást az R-nek), a szkriptbe írt parancsok pedig a Ctrl-EnterCtrl-Enter billentyűkombinációval futtathatóak. (Valójában ez sem mond ellent annak a szabálynak, hogy a konzolba írt dolgok futtatódnak, mert ha jobban megfigyeljük, akkor láthatjuk, hogy a Ctrl-EnterCtrl-Enter igazából csak átmásolja az utasítást a konzolba, majd beküldi.) Ha a szkriptben nincs kijelölve semmi, akkor a Ctrl-EnterCtrl-Enter azt a sort futtatja, amiben a kurzur áll, ha ki van jelölve valami, akkor a kijelölést. (Függetlenül attól, hogy az milyen, lehet több sor is, de egy sor részlete is). Amint volt róla szó, egy utasítás több sorba is átnyúlhat, ez nem okoz problémát, ilyenkor az R megáll, és várja a további sorokat. Az RStudio ezeket szinte mindig felismeri, és okosan jár el: ilyenkor a Ctrl-EnterCtrl-Enter valójában nem egy sort fog beküldeni, hanem az egész utasítást, fontos azonban, hogy ehhez a legelső sorban kell állnunk. Az egész szkript Ctrl-Alt-RCtrl-Alt-R kombinációval futtatható le, az egész szkript addig a sorig, amiben a kurzor áll, a Ctrl-Alt-BCtrl-Alt-B kombinációval, az egész szkript az aktuális sortól a végéig Ctrl-Alt-ECtrl-Alt-E kombinációval futtatható.\nAz egyes utasításokat új sorban kell kezdeni (tehát enter-rel kell elválasztani egymástól). Elvileg egy sorba több utasítás is írható, ekkor az egyes utasításokat pontosvesszővel (;) kell elválasztani, de ezt minden körülmények között kerüljük.\nEgy utasítás több sorba is átnyúlhat, ezt az R érzékeli, tehát, ha a sor végén még nem záródott be egy utasítás, akkor a következő sorban folytatja a feldolgozást. Azt, hogy új utasítást vár az R, onnan lehet látni, hogy a konzol elején a &gt; jel látható. Ha az utasítás nem ér véget a sorban (ezt az R magától érzékeli, például onnan, hogy egy kinyitott zárójel nem lett bezárva a beküldött sorban), akkor automatikusan azt feltételezi, hogy ez azért van, mert a következő sorban folytatjuk az utasítást. Ilyenkor a konzol elején a &gt; helyett a + jel látható. Ez jelzi, hogy a beküldött utasítást a következő folytatásának tekinti. Amint látja az R, hogy bezárult az utasítás, végrehajtja, és a konzol átugrik újra a &gt; jelre: várja a következő utasítást. Ez a viselkedés egy gyakori hiba forrása: ha beküldünk egy utasítást, amiből véletlenül lehagyjuk a záró zárójelet, akkor az R várni fogja a folytatást. Ha azonban ezt nem vesszük észre, és beküldjük a következő utasítást, akkor nem azt fogja végre hajtani (ahogy várnánk), hanem az előző folytatásának tekinti, és úgy próbálja értelmezni. Az eredmény vagy hiba lesz, vagy az, hogy továbbra is + üzemmódban fogja várni az utasításokat, mi pedig nem kapunk eredményt. Ha ilyen történik, tehát küldjük be az utasításokat, amik teljesen helyesek, és mégsem kapunk eredményt, akkor érdemes megnézni, hogy nem + (folytatás) üzemmódban van-e az R. Ha igen, akkor küldjünk be záró zárójelet, ha ezzel sikerül lezárnunk az utasítást, akkor nyilván hibát kapunk, de legalább visszavehetjük az irányítást.\nAz aktuálisan szerkesztett szkript Ctrl-SCtrl-S utasítással, vagy az ikonsorban a kék színű, egy darab floppy-lemezes ikonra kattintva menthető. A R-szkriptek alapértelmezett kiterjesztése a .R. Fontos, hogy ezt betartsuk, ugyanis az RStudio funkcionalitása csak akkor fog működni, ha a fájlról tudja, hogy az egy R szkript, és ezt a kiterjesztés alapján azonosítja. A Ctrl-Alt-SCtrl-Alt-S parancs, vagy a kék színű, több floppy-lemezes ikon az összes megnyitott szkriptet menti. Az RStudio képes megőrizni a nem mentett szkripteket is kilépésnél (a nevük Untitled majd utána egy sorszám), de erre a lehetőségre azért ne nagyon építsünk, mert egy összeomlásnál elveszhetnek; a biztos a névvel lementett szkript. Mentett szkriptet megnyitni a Ctrl-OCtrl-O billentyűparanccsal, vagy az ikonsorban a mappából kifelé mutató zöld nyilas ikonnal lehet.\nMinden kicsit is komolyabb munkánkat érdemes szkriptben megírni, hiszen így lesz az elemzési munkafolyamat reprodukálható. A konzolt tipikusan csak gyors, ismétlődően nem igényelt egyszerű számításokhoz használjuk, aminek az eredményére később nem lesz szükségünk, vagy szkriptírás közben az apróbb bizonytalanságok eldöntéséhez (mi is lesz ennek a parancsnak az eredménye?) használjuk.\nA kódunkat érdemes kommentelni, hogy később is világos legyen a működése. A komment olyan része a szkriptnek, melyet az R nem hajt végre, hiszen tudja, hogy nem R utasítás, hanem természetes nyelven írt megjegyzés. Ennek elkülönítésére a kommentjel szolgál, ez az R-ben a #: amennyiben az R egy ilyenhez ér, onnantól átugorja a leírtakat egészen a sor végéig. (Ez tehát ún. egysoros kommentjel.) A # az RStudio-ban a Ctrl-Shift-CCtrl-Shift-C-vel szúrható be gyorsan: azon sort kommentezi, mégpedig az elejétől fogva, amelyikben a kurzur áll, illetve ha ki van kommentezve, akkor ezt megszünteti. Többsoros kommentre nincs külön jel R-ben, viszont RStudio-ban a Ctrl-Shift-CCtrl-Shift-C használható több sort kijelölve is, ekkor mindegyiket kommentezi (vagy eltünteti a kommentjelet, ha ki vannak kommentezve).\nAz R kisbetű/nagybetű különbségre érzékeny (case sensitive) nyelv, tehát az a és az A nem ugyanaz, két különböző dolog.\nAz RStudio nagyon sok eszközzel segíti a kódolást: színekkel jelöli a különböző tartalmú szintaktikai elemeket, elkezdve egy nevet beírni, Tab-bal kiegészíti azt (automatikusan, ha csak egy lehetőség van, egy listát ad, ha több is), rövidebb vagy hosszabb súgót jelenít meg közvetlenül a beírt kód mellett stb. Segíti a kód identálását: a Ctrl-ICtrl-I kombináció szépen beindentálja a kijelölt részt. (Tipikus a Ctrl-ACtrl-A majd Ctrl-ICtrl-I kombináció: az előbbi kijelöli az egész szkriptet, így tehát ez mindent identál.)\nAz R kódolási stílus kapcsán csak egyetlen megjegyzés elöljáróban: vessző után rakjunk szóközt, de nyitó zárójel után, illetve záró zárójel előtt ne.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R szkriptek és az RStudio</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html",
    "href": "adattipusokadatszerkezetek.html",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "",
    "text": "2.1 Értékadás\nAz R programozásának megértéséhez szükséges egyik alapelemünk a változó: változóban tudunk információt tárolni, legyen az egyetlen szám vagy egy egész adatbázis, vagy akár egy regressziós modell. Mit jelent az, hogy információt tárolni? A változóban elmenthetünk információt (értékadás), azt módosíthatjuk, majd kiolvashatjuk és felhasználhatjuk. Változóból tetszőleges számút létrehozhatunk. Elsőként meg kell ismerkednünk a változó fogalmával, a neki történő értékadással, és azzal, hogy milyen típusú adatokat tudunk változóban tárolni\nVáltozó értéket az értékadás művelettel kap; ez kb. a „legyen egyenlő” módon olvasható ki. Az értékedás jele az R-ben a &lt;-. (A más programnyelveken megszokottabb =-t ne használjuk értékadásra, mert bár működne, de az R-es hagyományok szerint ezt egy másik helyzetre tartjuk fent, ezt majd később látni is fogjuk.) A nyíl bal oldalára kerül a változó, a jobb oldalára az érték, amit adni akarunk neki, például (a második sorban a változónév megadása egyszerűen kiíratja az értékét, csak hogy lássuk mi történt; hogy miért jelent kiíratást a változónév megadása, arra később még visszatérünk):\ntesttomeg &lt;- 72\ntesttomeg\n\n[1] 72\nMár létező változónak történő értékadásnál az előző érték elveszlik, és felülíródik az aktuálisan megadottal:\ntesttomeg &lt;- 62\ntesttomeg\n\n[1] 62\nFurcsa lehet ez a nyíl jel az értékadás jelölésére, de „didaktikailag” nagyon jó: szépen mutatja, szinte vizuálisan is, hogy a 72 „bemegy” a testtomeg változóba. (Elvileg használható a -&gt; is értékadásra, ilyenkor értelemszerűen fordul a helyzet, de ezt ritkán szokták alkalmazni.)\nAmi szembeötlik: ez az utasítás gond nélkül lefut, miközben sehol nem deklaráltuk, hogy a testtomeg legyen egy változó, pláne nem adtuk meg, hogy milyen típusú adatot akarunk benne tárolni! Furcsa lehet józan ésszel is, hiszen logikus lenne, hogy előbb valamilyen módon „létre kell hoznunk” egy változót, mielőtt egyáltalán bármit el tudunk tárolni benne. Hogyhogy nem kellett előbb megadni, hogy szeretnénk egy ilyen változót, például azért, hogy az R le tudja foglalni a helyét a memóriában? Azt is várhatnánk, hogy meg kell adni a típusát, tehát, hogy milyen jellegű adatot akarunk benne tárolni (számot, szöveget, dátumot, kis számot, nagy számot stb.), hiszen logikus lenne a feltételezés, hogy ettől függ, hogy mit kell az R-nek tennie, például mennyi memóriát kell foglalnia, tehát okkal várhatnánk, hogy ezt is meg kell adni. De nem! Más programnyelvekben valóban lehet ez a helyzet, de itt nem.\nAz R „intelligensen” kitalált mindent: mivel látja, hogy korábban testtomeg nevű változó még nem létezett, ezért egyetlen szó nélkül, automatikusan létrehozza, illetve abból, hogy mit adtunk neki értékül, azt is kitalálta, hogy milyen legyen a típusa, jelen esetben szám. Majd természetesen az értékét is beállítja arra, amit megadtunk; ez a szigorúan vett értékadás.\nAz „intelligensen” szót nem véletlenül tettem idézőjelbe. Ez egy példa az R egy meglehetősen általános filozófiájára, amire később még sok további példát fogunk látni: az R „megengedi trehányságot” és igyekszik kitalálni, hogy mit akarhattunk. Bár ez első ránézésre rendkívül kényelmesnek hangzik, fontos hangsúlyozni, hogy ez egy kétélű fegyver! Egyfelől ugyanis valóban nagyon kényelmes, jelen esetben, hogy nem kell törődnünk a változók előzetes deklarálásával, típusuk megadásával, de másrészt így kiesik egy védővonal, ami megóvhatna minket a saját hibáinktól – hiszen a deklaráció rákényszerít(ett volna) minket arra, hogy jobban végiggondoljuk a változókkal kapcsolatos kérdéseket. Így viszont könnyebben előfordulhat, hogy olyat csinálunk, amit igazából nem szeretnénk, ráadásul úgy, hogy észre sem vesszük!\nPéldául, azt írjuk később a kódban, hogy:\ntestomeg &lt;- 82\nMi fog történni? Semmi! Pontosabban szólva, valami nagyon is fog történni, létrejön egy másik változó, miközben maga az utasítás egyetlen hang, hiba, figyelmeztetes, minden nélkül lefut! Ha kellett volna előzetesen deklarálni a változókat, akkor ilyen nem fordulhatna elő, hiszen a gép azonnal szólna, hogy testomeg nevű változót nem deklaráltunk.\nVagy egy másik példa. Később azt írjuk (a „később” jelentheti azt, hogy három nappal, és ezer sorral lejjebb, és persze a változó neve sem biztos, hogy ennyire egyértelmű segítséget jelent!), hogy:\ntesttomeg &lt;- \"András\"\nMi történik? Megint csak: semmi, az utasítás egyetlen hang, hiba, figyelmeztetés, minden nélkül lefut, és szó nélkül átállítja a változó típusát, hogy be tudja állítani \"András\" értékre. Ha kellett volna deklarálni a változó típusát is, az kényelmetlenebb lett volna, igen, de segítene elkerülni az ilyen hibákat, hiszen a gép azonnal szólna, hogy a testtomeg változó típusa szám, úgyhogy abba nem rakhatunk bele egy szöveget.\nAmint mondtam, a „megengedi a trehányságot”, ez a kétélű fegyver (kényelmesebb, gyorsabb, de veszélyesebb, kevesebb a hiba elleni védelmi vonal) meglehetősen általános filozófia az R-ben, de ennek a konkrét viselkedésnek külön neve van a programozás-elméletben. Azt mondják, hogy egy programnyelv statikus típusrendszerű, ha a változókat előzetesen deklarálni kell, megadva a típusukat. Ez plusz feladat, de cserében a gép meg tud minket védeni a fentihez hasonló hibáktól. Az R azonban dinamikus típusrendszerű, vagyis a típust nem kell előre megadni1, és akár, mint láttuk, menet közben is változtatható. Ez sok szempontból egyszerűbb és flexibilisebb, de kinyitja az ajtót a fentihez hasonló hibákhoz.\nR-ben a változónév karakterekből, számokból, a . és a _ jelekből állhat, de nem kezdődhet számmal vagy _ jellel, és ha . jellel kezdődik, akkor utána nem jöhet szám. (Bizonyos, úgynevezett foglalt szavakat, amiket az R nyelv használ, nem választhatunk változónévnek. Ezekből nagyon kevés van, így annyiban óvatosnak kell lenni, hogy az R egy sor szokásos függvényét simán felüldefiniálhatjunk, ha létrehozunk olyan nevű változót.) Érdekes módon az, hogy az R mit ért karakter alatt, függhet az adott számítógép beállításaitól, de a legbiztosabb, ha a standard latin betűs (ASCII) karaktereket használjuk csak. (Azaz: lehetőleg ne használjunk ékezetes betűt változónévként. Elvileg el lehet vele boldogulni – adott esetben speciális szimbólummal jelölve, hogy az egy változónév – de nem éri meg a vesződséget, csomagokban kiszámíthatatlan gondokat okozhat.)\nEgy fontos általános szabály, hogy ha egy utasításban értékadás van, akkor az eltárolás a „háttérben” történik meg, a konzolra nem íródik ki semmi. (Természetesen vannak kivételek, olyan számítások, amik mellékhatásként mindenképp kiírnak valamit a konzolra.) Értékadás nélküli utasítás futtatásánál viszont épp fordított a helyzet: az eredmény kiíratódik a konzolra, de nem tárolódik el sehol. Ha egy értékadást gömbölyű zárójelekbe ágyazunk ((a &lt;- 1)), akkor el is tárolódik és ki is íratódik az eredmény; a gyakorlatban ritkán használjuk.\n(Egy apró jótanács. Mi van akkor, ha lefuttatunk egy rendkívül hosszú utasítást, de véletlenül elfelejtjük benyilazni egy változóba… azaz az eredmény megjelenik a konzolon, viszont nem tárolódott le! Most futtathatjuk az egészet újra?! Szerencsére nem: az R valójában nyíl nélkül is eltárolja egy speciális változóban az eredményt, a neve .Last.value. Ha tehát ilyen történik, akkor ne essünk kétségbe, ezt speciális változót adjuk értékül a változónknak. De vigyázzunk, ilyen módon mindig csak a legutóbbi utasítás eredménye érhető el.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html#adattípusok",
    "href": "adattipusokadatszerkezetek.html#adattípusok",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "2.2 Adattípusok",
    "text": "2.2 Adattípusok\nElsőként meg kell ismerkednünk azzal, hogy a korábban említett típusok pontosan milyenek lehetnek – ez lényegében azt adja meg, hogy milyen jellegű adatot tárolunk az adott változóban. Az R-ben 4 fontos adattípus van: numerikus, amelybe a valós és az egész típusok tartoznak alcsoportként, a szöveg és a logikai. (Elvileg még két további típus létezik, a complex és a raw, ezek nagyon ritkán használatosak.) Létezik még egy fogalom, a factor, ami adattípusnak tűnik, de mégsem az (egy másik típus speciális esete), erről később fogunk szót ejteni.\nA változó típusát az R többféle módon is értelmezi, de a gyakorlatban inkább az str függvény ismerete a fontosabb, mellyel komplexebb adatszerkezetekről is jól áttekinthető információt tudunk nyerni.\n\n2.2.1 Numerikus\nSzámok tárolására a numerikus típus (numeric, rövidítve num) szolgál.\nAlapbeállításban ez a típus valós számokat tárol (precízen: double pontosságú lebegőpontos). A double pontossága jellemzően 53 bit (kb. \\(2\\cdot 10^{-308}\\)-tól \\(2\\cdot 10^{308}\\)-ig nagyjából \\(2\\cdot 10^{-16}\\) felbontással; az adott architektúra vonatkozó értéket a .Machine megmondja).\nAz R-ben a tizedestörteket angol stílusban kell megadni, tehát a tizedesjelölő a pont, nem a vessző.\nÍgy néz ki egy numerikus adattal történő értékadás:\n\nszam &lt;- 3.1\nszam\n\n[1] 3.1\n\nstr(szam)\n\n num 3.1\n\n\nNézzük meg, hogy csakugyan case sensitive a nyelv:\n\nSZAM\n\nError: object 'SZAM' not found\n\nSzam\n\nError: object 'Szam' not found\n\nszaM\n\nError: object 'szaM' not found\n\n\nFontos megjegyezni, hogy attól mert valami történetesen egész, az R még nem fogja egész számként kezelni, ugyanúgy valósnak veszi:\n\nszam &lt;- 3\nstr(szam)\n\n num 3\n\n\nHa egészet (integer) akarunk, azt explicite jelölni kell a szám után fűzött L utótaggal:\n\negesz &lt;- 3L\negesz\n\n[1] 3\n\nstr(egesz)\n\n int 3\n\n\n\n\n2.2.2 Szöveg\nSzemben más programnyelvvek, az R-ben nincs megkülönböztetve az egy karakter, és a több karakterből álló karakterfüzér (sztring). Számára mindkettő ugyanolyan típusú (character, rövidítve chr).\nA szöveget idézőjelek közé kell tenni, ebből tudja az R, hogy az egy – szöveget tartalmazó – konstans, és nem egy kiértékelendő kifejezés (különben a kiskutya beírásakor egy ilyen nevű változót kezdene keresni az R):\n\nszoveg &lt;- \"kiskutya\"\nszoveg\n\n[1] \"kiskutya\"\n\nstr(szoveg)\n\n chr \"kiskutya\"\n\ntypeof(szoveg)\n\n[1] \"character\"\n\n\nA sztringkonstansokat idézőjellel kell jelölni. Az R megengedi a dupla (\" \") és a szimpla (' ') idézőjel használatát is, de az előbbi a preferált (az R általi kiírás is mindenképp ilyennel történik), az utóbbit érdemes az egymásbaágyazott esetekre használni (tehát, ha egy sztringkonstans tartalmaz egy idézőjeles részt2). Természetesen az \"1\" kifejezés nem az 1 számot, hanem az 1-et (mint karaktert) tartalmazó sztringet jelenti.\nAz RStudio-ban a szintaxis highlighting segít, a szövegek alapértelmezés szerint zöld színnel jelennek meg.\nA szövegben elhelyezhetünk különféle speciális jeleket is, mint a tabulátor vagy sortörés, ezeket backslash jelöli (például a tabulátor \\t).\n\n\n\n2.2.3 Logikai\nLogikai (logical, rövidítve logi) típusú változóban bináris, azaz igaz/hamis (igen/nem) értékeket tárolhatunk. A két értéket foglalt szavak jelzik, az igazat a TRUE, a hamisat a FALSE (a case sensitivity miatt természetesen fontos, hogy csupa nagybetű!):\n\nlogikai &lt;- TRUE\nlogikai\n\n[1] TRUE\n\nstr(logikai)\n\n logi TRUE\n\ntypeof(logikai)\n\n[1] \"logical\"\n\n\nA TRUE rövidíthető T-nek, a FALSE pedig F-nek.\nTermészetesen ilyen bináris adatokat nyugodtan tárolhatnánk numerikus változóként is (például 0 és 1 formájában), de a logikai változó előnye, hogy van szemantikája, azaz maga az adattípus is kifejezi, hogy az egyes értékek mit jelentenek, igazat és hamisat (nem pedig számokat), ez sokszor kényelmesebb és tisztább. Emellett értelemszerűen a memóriaigénye is kisebb, bár ennek a legtöbb esetben valószínűleg nincs érdemi jelentősége.\n\n\n\n2.2.4 Az adattípusokhoz kapcsolódó néhány fontos művelet\nAdott típus tesztelése az is.&lt;tipus&gt; alakban lehet:\n\nis.integer(szam)\n\n[1] FALSE\n\nis.integer(egesz)\n\n[1] TRUE\n\nis.integer(szoveg)\n\n[1] FALSE\n\nis.integer(logikai)\n\n[1] FALSE\n\n\nAz is.numeric azt jelenti, hogy is.integer vagy is.double:\n\nis.double(szam)\n\n[1] TRUE\n\nis.double(egesz)\n\n[1] FALSE\n\nis.numeric(szam)\n\n[1] TRUE\n\nis.numeric(egesz)\n\n[1] TRUE\n\n\nAdott típussá alakítás as.&lt;tipus&gt; alakban lehet:\n\nas.character(szam)\n\n[1] \"3\"\n\nas.numeric(szoveg)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\nas.numeric(\"2.4\" )\n\n[1] 2.4\n\nas.numeric(logikai)\n\n[1] 1\n\n\nA sémát már a fentiek is mutatják: a konvertálásnál egy „erősorrend”, jelesül character &lt; double = integer &lt; logical, amely irányban mindig lehet konvertálni (a T 1-re, a F 0-ra alakul, a többi értelemszerű). A sorrenddel ellentétesen is elképzelhető, hogy lehet konvertálni, de ez már nem biztos, azon múlik, hogy értelmesen végrehajtható-e (a \"kiskutya\" nem konvertálható számmá, az \"1\" igen). Sok függvény automatikusan konvertál, például ha egy logikai igaz értékhez hozzáadunk 1-et, akkor 2-t kapunk, mert a háttérben, szó nélkül, át fogja konvertálni számmá.\nA sikertelen konverziók NA-t adnak, amely az R-ben lényegében a „hiányzó érték” jele.\nSpeciális szerepe van még a NULL-nak (ez inkább olyasmit jelöl, hogy „üres objektum”), illetve az NaN-nek (not-a-number, tipikusan olyan adja, mint például ha negatív szám logaritmusát vesszük).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html#adatszerkezetek-és-indexelés",
    "href": "adattipusokadatszerkezetek.html#adatszerkezetek-és-indexelés",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "2.3 Adatszerkezetek és indexelés",
    "text": "2.3 Adatszerkezetek és indexelés\nMost, hogy ismerjük az adattípusokat, azzal kell folytatnunk, hogy ezekből milyen komplexebb struktúrák rakhatóak össze.\n\n2.3.1 Vektor\nA vektor homogén, egydimenziós adatszerkezet. Egydimenziós, mert egy „kiterjedése” van, egy indexszel hivatkozhatunk az elemeire, és homogén, mert minden benne lévő adat ugyanolyan típusú kell legyen. Szemben a „vektor” matematikai fogalmával, nem kötelező, hogy ezek számok legyenek, de mindenképp ugyanolyannak kell lennie a típusuknak.\nVektor legegyszerűbb módon az elemei felsorolásával hozható létre, ehhez a c függvény használható:\n\nszamvektor &lt;- c(1, 4, 5, -2, 3.5, 10)\nszamvektor\n\n[1]  1.0  4.0  5.0 -2.0  3.5 10.0\n\n\nSok függvény vektort ad vissza eredményül, például a seq-val generálhatunk egy reguláris sorozatot. A függvényekről később lesz szó, úgyhogy most kommentár nélkül: a seq(1, 101, 2) hívás kidobja a számokat 1-től 101-ig 2-esével:\n\nseq(1, 101, 2)\n\n [1]   1   3   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37\n[20]  39  41  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75\n[39]  77  79  81  83  85  87  89  91  93  95  97  99 101\n\n\nAz eredmény egy vektor.\nArra a speciális esetre, hogy 1-esével lépkedünk, olyan sűrűn van szükség, hogy arra van egy külön, rövidebb jelölés, a ::\n\n1:100\n\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n\n\nA sorok elején lévő, szögletes zárójelbe írt számok nem részei a vektornak, az az olvashatóságot segíti: ha nagyon hosszú vektorban kell egy adott elem pozícióját megtalálni, akkor nem a legelejétől kell számolni, elég a sor elejétől menni.\nFeltűnhet, hogy a korábbi szam kiíratás esetén is megjelent egy [1] a sor elején. Ez nem véletlen: a valóságban „skalár” nincs az R-ben, igazából a szam is egy vektor (csak épp egy elemből áll).\nAhogy volt róla szó, nem csak numerikus adatokból képezhető vektor, hanem bármilyenből:\n\nkaraktervektor &lt;- c(\"a\", \"b\", \"xyz\")\nkaraktervektor\n\n[1] \"a\"   \"b\"   \"xyz\"\n\n\nA vektor homogén, ezért az alábbi utasítások csak és kizárólag azért futnak le mégis, mert a háttérben ilyenkor az R a „leggyengébbre” konvertálja az összeset (hogy kikényszerítse a homogenitást):\n\nc(1, \"a\")\n\n[1] \"1\" \"a\"\n\nc(2, TRUE)\n\n[1] 2 1\n\n\nA vektor elemei el is nevezhetőek; a nevek később a names-zel lekérhetőekk:\n\nszamvektor &lt;- c(elso = 4, masodik = 1, harmadik = 7)\nszamvektor\n\n    elso  masodik harmadik \n       4        1        7 \n\nnames(szamvektor)\n\n[1] \"elso\"     \"masodik\"  \"harmadik\"\n\n\nA names érdekesen viselkedik, mert nem csak megadja a neveket, de bele is nyilazhatunk értéket, ez esetben beállítja:\n\nnames(szamvektor) &lt;- c(\"egy\", \"ketto\", \"harom\")\nszamvektor\n\n  egy ketto harom \n    4     1     7 \n\n\nAz adatszerkezetek esetén egy alapvető kérdés az indexelés, tehát, hogy hogyan hivatkozhatunk adott pozicióban lévő elemre vagy elemekre. Ennek az R-ben meglehetősen sok módja lehetséges, de általános, hogy az indexelést a szögletes zárójel jelöli. (Később fogunk még egy szintaktikai elemet látni indexelésre.)\nA legegyszerűbb eset, ha egyetlen számmal indexelünk: ekkor az adott pozícióban lévő elemet kapjuk meg. Például:\n\nszamvektor[3]\n\nharom \n    7 \n\n\nMegtehetjük azt is, hogy nem egy számot, hanem egy vektort adunk át, ekkor a felsorolt pozícióban lévő elemeket kapjuk, a felsorolás sorrendjében:\n\nszamvektor[c(1, 3)]\n\n  egy harom \n    4     7 \n\n\n(Ugye látjuk, hogy ez a kettő igazából ugyanaz? Az előbbi példa is vektorral indexeltm hiszen „egy szám” nincsen, az is vektor.)\nEgy elem kiválasztható többször is, illetve tetszőleges sorrendben:\n\nszamvektor[c(2, 2, 1, 3, 2, 3, 1, 1)]\n\nketto ketto   egy harom ketto harom   egy   egy \n    1     1     4     7     1     7     4     4 \n\n\nNemlétező elem indexelése NA-t ad:\n\nszamvektor[10]\n\n&lt;NA&gt; \n  NA \n\n\nA második alapvető megoldás a logikai vektorral való indexelés: ekkor egy ugyanolyan hosszú vektort kell átadnunk, mint az indexelendő vektor, és azokat az elemeke választja ki, ahol logikai igaz érték van:\n\nszamvektor[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)]\n\n  egy harom  &lt;NA&gt;  &lt;NA&gt; \n    4     7    NA    NA \n\n\nValójában azonban ez is működik, hiába rövidebb az indexelő vektor:\n\nszamvektor[c(TRUE, TRUE, FALSE)]\n\n  egy ketto \n    4     1 \n\n\nEz egy újabb példa a kétélű flexibilitásra: azért fog működni, mert ilyenkor az R „reciklálja” az indexelő vektort.\nLehetséges negatív indexelés is, ez kiválaszt mindent, kivéve amit indexeltünk:\n\nszamvektor[-3]\n\n  egy ketto \n    4     1 \n\nszamvektor[-c(1, 3)]\n\nketto \n    1 \n\n\nHa vannak elnevezések, akkor azok használhatóak indexelésre is:\n\nszamvektor[\"masodik\"]\n\n&lt;NA&gt; \n  NA \n\nszamvektor[c(\"masodik\", \"utolso\")]\n\n&lt;NA&gt; &lt;NA&gt; \n  NA   NA \n\n\nAz indexelés és az értékadás kombinálható is:\n\nszamvektor[ 3 ] &lt;- 99\nszamvektor\n\n  egy ketto harom \n    4     1    99 \n\nszamvektor[ 10 ]\n\n&lt;NA&gt; \n  NA \n\n\nHa nemlétezőnek adunk értéket, automatikusan kiterjeszti a vektort, a többi helyre pedig NA kerül (megint újabb példa a kétélű flexibilitásra):\n\nszamvektor[ 10 ] &lt;- 999\nszamvektor\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n\n\n\n2.3.2 Mátrix\nA mátrix homogén, kétdimenziós adatszerkezet.\nLegegyszerűbben úgy tölthető fel, ha egy vektort áttördelünk, a matrix függvény használatával (az nc argumentummal az oszlopok, az nr argumentummal a sorok számát állíthatjuk be, értelemszerűen elég a kettőből egyet megadni):\n\nszammatrix &lt;- matrix( 1:6, nc = 2 )\nszammatrix\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n\nAlapból oszlopok szerint tördel, de a byrow argumentummal ezt átállíthatjuk:\n\nmatrix( 1:6, nc = 2, byrow = TRUE )\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\n\nA dimenzió, illetve külön a sorok és oszlopok száma könnyen lekérhető:\n\ndim( szammatrix )\n\n[1] 3 2\n\nnrow( szammatrix )\n\n[1] 3\n\nncol( szammatrix )\n\n[1] 2\n\n\nA mátrix oszlopai és sorai is elnevezhetőek, emiatt itt nem egy names van, hanem egy row.names és egy names, ez utóbbi az oszlopnév, de egyebekben teljesen hasonlóan viselkednek.\nIndexelés ugyanúgy végezhető, csak épp mindkét dimenzióra mondanunk kell valamit; a kettő vesszővel választandó el:\n\nszammatrix[ c( 2, 3 ), 2 ]\n\n[1] 5 6\n\n\nMindkét dimenzió tetszőleges korábban látott módon indexelhető, tehát a különböző módok keverhetőek is:\n\nszammatrix[ c( 1, 2 ), c( T, F ) ]\n\n[1] 1 2\n\n\nHa egy dimenziót nem indexelünk, akkor az R úgy érti, hogy onnan minden elem (de a vessző ekkor sem hagyható el!):\n\nszammatrix[ 2, ]\n\n[1] 2 5\n\n\n\n\n2.3.3 Tömb (array)\nA tömb (array) homogén, \\(n\\)-dimenziós adatszerkezet (nem foglalkozunk vele részletesebben, ritkán használatos).\n\n\n2.3.4 Data frame\nA data frame (adatkeret) heterogén, kétdimenziós, rektanguláris adatszerkezet. Pontosabban szólva félig heterogén: az oszlopok homogének, de a különböző oszlopok típusai eltérhetnek egymástól. Lényegében tehát - nem feltétlenül ugyanolyan típusú - vektorok összefogva; a rektanguláris azt jelenti, hogy minden vektor ugyanolyan hosszú kell legyen.\nEz a legtipikusabb adatszerkezet orvosi adatok tárolására: sorokban a megfigyelési egységek, oszlopokban a változók.\nA data paranccsal egy kiegészítő csomagban található kész adat tölthető be:\n\ndata( birthwt, package = \"MASS\" )\nbirthwt\n\n    low age lwt race smoke ptl ht ui ftv  bwt\n85    0  19 182    2     0   0  0  1   0 2523\n86    0  33 155    3     0   0  0  0   3 2551\n87    0  20 105    1     1   0  0  0   1 2557\n88    0  21 108    1     1   0  0  1   2 2594\n89    0  18 107    1     1   0  0  1   0 2600\n91    0  21 124    3     0   0  0  0   0 2622\n92    0  22 118    1     0   0  0  0   1 2637\n93    0  17 103    3     0   0  0  0   1 2637\n94    0  29 123    1     1   0  0  0   1 2663\n95    0  26 113    1     1   0  0  0   0 2665\n96    0  19  95    3     0   0  0  0   0 2722\n97    0  19 150    3     0   0  0  0   1 2733\n98    0  22  95    3     0   0  1  0   0 2751\n99    0  30 107    3     0   1  0  1   2 2750\n100   0  18 100    1     1   0  0  0   0 2769\n101   0  18 100    1     1   0  0  0   0 2769\n102   0  15  98    2     0   0  0  0   0 2778\n103   0  25 118    1     1   0  0  0   3 2782\n104   0  20 120    3     0   0  0  1   0 2807\n105   0  28 120    1     1   0  0  0   1 2821\n106   0  32 121    3     0   0  0  0   2 2835\n107   0  31 100    1     0   0  0  1   3 2835\n108   0  36 202    1     0   0  0  0   1 2836\n109   0  28 120    3     0   0  0  0   0 2863\n111   0  25 120    3     0   0  0  1   2 2877\n112   0  28 167    1     0   0  0  0   0 2877\n113   0  17 122    1     1   0  0  0   0 2906\n114   0  29 150    1     0   0  0  0   2 2920\n115   0  26 168    2     1   0  0  0   0 2920\n116   0  17 113    2     0   0  0  0   1 2920\n117   0  17 113    2     0   0  0  0   1 2920\n118   0  24  90    1     1   1  0  0   1 2948\n119   0  35 121    2     1   1  0  0   1 2948\n120   0  25 155    1     0   0  0  0   1 2977\n121   0  25 125    2     0   0  0  0   0 2977\n123   0  29 140    1     1   0  0  0   2 2977\n124   0  19 138    1     1   0  0  0   2 2977\n125   0  27 124    1     1   0  0  0   0 2922\n126   0  31 215    1     1   0  0  0   2 3005\n127   0  33 109    1     1   0  0  0   1 3033\n128   0  21 185    2     1   0  0  0   2 3042\n129   0  19 189    1     0   0  0  0   2 3062\n130   0  23 130    2     0   0  0  0   1 3062\n131   0  21 160    1     0   0  0  0   0 3062\n132   0  18  90    1     1   0  0  1   0 3062\n133   0  18  90    1     1   0  0  1   0 3062\n134   0  32 132    1     0   0  0  0   4 3080\n135   0  19 132    3     0   0  0  0   0 3090\n136   0  24 115    1     0   0  0  0   2 3090\n137   0  22  85    3     1   0  0  0   0 3090\n138   0  22 120    1     0   0  1  0   1 3100\n139   0  23 128    3     0   0  0  0   0 3104\n140   0  22 130    1     1   0  0  0   0 3132\n141   0  30  95    1     1   0  0  0   2 3147\n142   0  19 115    3     0   0  0  0   0 3175\n143   0  16 110    3     0   0  0  0   0 3175\n144   0  21 110    3     1   0  0  1   0 3203\n145   0  30 153    3     0   0  0  0   0 3203\n146   0  20 103    3     0   0  0  0   0 3203\n147   0  17 119    3     0   0  0  0   0 3225\n148   0  17 119    3     0   0  0  0   0 3225\n149   0  23 119    3     0   0  0  0   2 3232\n150   0  24 110    3     0   0  0  0   0 3232\n151   0  28 140    1     0   0  0  0   0 3234\n154   0  26 133    3     1   2  0  0   0 3260\n155   0  20 169    3     0   1  0  1   1 3274\n156   0  24 115    3     0   0  0  0   2 3274\n159   0  28 250    3     1   0  0  0   6 3303\n160   0  20 141    1     0   2  0  1   1 3317\n161   0  22 158    2     0   1  0  0   2 3317\n162   0  22 112    1     1   2  0  0   0 3317\n163   0  31 150    3     1   0  0  0   2 3321\n164   0  23 115    3     1   0  0  0   1 3331\n166   0  16 112    2     0   0  0  0   0 3374\n167   0  16 135    1     1   0  0  0   0 3374\n168   0  18 229    2     0   0  0  0   0 3402\n169   0  25 140    1     0   0  0  0   1 3416\n170   0  32 134    1     1   1  0  0   4 3430\n172   0  20 121    2     1   0  0  0   0 3444\n173   0  23 190    1     0   0  0  0   0 3459\n174   0  22 131    1     0   0  0  0   1 3460\n175   0  32 170    1     0   0  0  0   0 3473\n176   0  30 110    3     0   0  0  0   0 3544\n177   0  20 127    3     0   0  0  0   0 3487\n179   0  23 123    3     0   0  0  0   0 3544\n180   0  17 120    3     1   0  0  0   0 3572\n181   0  19 105    3     0   0  0  0   0 3572\n182   0  23 130    1     0   0  0  0   0 3586\n183   0  36 175    1     0   0  0  0   0 3600\n184   0  22 125    1     0   0  0  0   1 3614\n185   0  24 133    1     0   0  0  0   0 3614\n186   0  21 134    3     0   0  0  0   2 3629\n187   0  19 235    1     1   0  1  0   0 3629\n188   0  25  95    1     1   3  0  1   0 3637\n189   0  16 135    1     1   0  0  0   0 3643\n190   0  29 135    1     0   0  0  0   1 3651\n191   0  29 154    1     0   0  0  0   1 3651\n192   0  19 147    1     1   0  0  0   0 3651\n193   0  19 147    1     1   0  0  0   0 3651\n195   0  30 137    1     0   0  0  0   1 3699\n196   0  24 110    1     0   0  0  0   1 3728\n197   0  19 184    1     1   0  1  0   0 3756\n199   0  24 110    3     0   1  0  0   0 3770\n200   0  23 110    1     0   0  0  0   1 3770\n201   0  20 120    3     0   0  0  0   0 3770\n202   0  25 241    2     0   0  1  0   0 3790\n203   0  30 112    1     0   0  0  0   1 3799\n204   0  22 169    1     0   0  0  0   0 3827\n205   0  18 120    1     1   0  0  0   2 3856\n206   0  16 170    2     0   0  0  0   4 3860\n207   0  32 186    1     0   0  0  0   2 3860\n208   0  18 120    3     0   0  0  0   1 3884\n209   0  29 130    1     1   0  0  0   2 3884\n210   0  33 117    1     0   0  0  1   1 3912\n211   0  20 170    1     1   0  0  0   0 3940\n212   0  28 134    3     0   0  0  0   1 3941\n213   0  14 135    1     0   0  0  0   0 3941\n214   0  28 130    3     0   0  0  0   0 3969\n215   0  25 120    1     0   0  0  0   2 3983\n216   0  16  95    3     0   0  0  0   1 3997\n217   0  20 158    1     0   0  0  0   1 3997\n218   0  26 160    3     0   0  0  0   0 4054\n219   0  21 115    1     0   0  0  0   1 4054\n220   0  22 129    1     0   0  0  0   0 4111\n221   0  25 130    1     0   0  0  0   2 4153\n222   0  31 120    1     0   0  0  0   2 4167\n223   0  35 170    1     0   1  0  0   1 4174\n224   0  19 120    1     1   0  0  0   0 4238\n225   0  24 116    1     0   0  0  0   1 4593\n226   0  45 123    1     0   0  0  0   1 4990\n4     1  28 120    3     1   1  0  1   0  709\n10    1  29 130    1     0   0  0  1   2 1021\n11    1  34 187    2     1   0  1  0   0 1135\n13    1  25 105    3     0   1  1  0   0 1330\n15    1  25  85    3     0   0  0  1   0 1474\n16    1  27 150    3     0   0  0  0   0 1588\n17    1  23  97    3     0   0  0  1   1 1588\n18    1  24 128    2     0   1  0  0   1 1701\n19    1  24 132    3     0   0  1  0   0 1729\n20    1  21 165    1     1   0  1  0   1 1790\n22    1  32 105    1     1   0  0  0   0 1818\n23    1  19  91    1     1   2  0  1   0 1885\n24    1  25 115    3     0   0  0  0   0 1893\n25    1  16 130    3     0   0  0  0   1 1899\n26    1  25  92    1     1   0  0  0   0 1928\n27    1  20 150    1     1   0  0  0   2 1928\n28    1  21 200    2     0   0  0  1   2 1928\n29    1  24 155    1     1   1  0  0   0 1936\n30    1  21 103    3     0   0  0  0   0 1970\n31    1  20 125    3     0   0  0  1   0 2055\n32    1  25  89    3     0   2  0  0   1 2055\n33    1  19 102    1     0   0  0  0   2 2082\n34    1  19 112    1     1   0  0  1   0 2084\n35    1  26 117    1     1   1  0  0   0 2084\n36    1  24 138    1     0   0  0  0   0 2100\n37    1  17 130    3     1   1  0  1   0 2125\n40    1  20 120    2     1   0  0  0   3 2126\n42    1  22 130    1     1   1  0  1   1 2187\n43    1  27 130    2     0   0  0  1   0 2187\n44    1  20  80    3     1   0  0  1   0 2211\n45    1  17 110    1     1   0  0  0   0 2225\n46    1  25 105    3     0   1  0  0   1 2240\n47    1  20 109    3     0   0  0  0   0 2240\n49    1  18 148    3     0   0  0  0   0 2282\n50    1  18 110    2     1   1  0  0   0 2296\n51    1  20 121    1     1   1  0  1   0 2296\n52    1  21 100    3     0   1  0  0   4 2301\n54    1  26  96    3     0   0  0  0   0 2325\n56    1  31 102    1     1   1  0  0   1 2353\n57    1  15 110    1     0   0  0  0   0 2353\n59    1  23 187    2     1   0  0  0   1 2367\n60    1  20 122    2     1   0  0  0   0 2381\n61    1  24 105    2     1   0  0  0   0 2381\n62    1  15 115    3     0   0  0  1   0 2381\n63    1  23 120    3     0   0  0  0   0 2410\n65    1  30 142    1     1   1  0  0   0 2410\n67    1  22 130    1     1   0  0  0   1 2410\n68    1  17 120    1     1   0  0  0   3 2414\n69    1  23 110    1     1   1  0  0   0 2424\n71    1  17 120    2     0   0  0  0   2 2438\n75    1  26 154    3     0   1  1  0   1 2442\n76    1  20 105    3     0   0  0  0   3 2450\n77    1  26 190    1     1   0  0  0   0 2466\n78    1  14 101    3     1   1  0  0   0 2466\n79    1  28  95    1     1   0  0  0   2 2466\n81    1  14 100    3     0   0  0  0   2 2495\n82    1  23  94    3     1   0  0  0   0 2495\n83    1  17 142    2     0   0  1  0   0 2495\n84    1  21 130    1     1   0  1  0   3 2495\n\n\nCsak a felső néhány sor a head paranccsal kérhető le (az alsó néhány sor pedig a tail-lel):\n\nhead( birthwt )\n\n   low age lwt race smoke ptl ht ui ftv  bwt\n85   0  19 182    2     0   0  0  1   0 2523\n86   0  33 155    3     0   0  0  0   3 2551\n87   0  20 105    1     1   0  0  0   1 2557\n88   0  21 108    1     1   0  0  1   2 2594\n89   0  18 107    1     1   0  0  1   0 2600\n91   0  21 124    3     0   0  0  0   0 2622\n\n\nAz oszlopok és a sorok is elnevezhetőek:\n\nstr( birthwt )\n\n'data.frame':   189 obs. of  10 variables:\n $ low  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ age  : int  19 33 20 21 18 21 22 17 29 26 ...\n $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...\n $ race : int  2 3 1 1 1 3 1 3 1 1 ...\n $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...\n $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...\n $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...\n $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n\nnames( birthwt )\n\n [1] \"low\"   \"age\"   \"lwt\"   \"race\"  \"smoke\" \"ptl\"   \"ht\"    \"ui\"    \"ftv\"  \n[10] \"bwt\"  \n\ncolnames( birthwt )\n\n [1] \"low\"   \"age\"   \"lwt\"   \"race\"  \"smoke\" \"ptl\"   \"ht\"    \"ui\"    \"ftv\"  \n[10] \"bwt\"  \n\n\nAz adatkeret a mátrixhoz hasonlóan indexelhető:\n\nbirthwt[ 3, ]\n\n   low age lwt race smoke ptl ht ui ftv  bwt\n87   0  20 105    1     1   0  0  0   1 2557\n\nbirthwt[ 3, 4 ]\n\n[1] 1\n\nbirthwt[ 3, c( 5, 6 ) ]\n\n   smoke ptl\n87     1   0\n\n\nSőt, ha vannak elnevezéseink, az is használható. A következő 4 mind egyenértékű:\n\nbirthwt[ , 10  ]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nbirthwt$bwt\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nbirthwt[ , \"bwt\" ]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nbirthwt[[ \"bwt\" ]]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\n\nA nem dupla szögletes zárójellel történő indexelés eltérése, hogy nem a kiválasztott vektort, hanem egy csak a kiválasztott vektorból álló data frame-et ad vissza:\n\nbirthwt[[ \"bwt\" ]]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nstr( birthwt[[ \"bwt\" ]] )\n\n int [1:189] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n\nhead( birthwt[ \"bwt\" ] )\n\n    bwt\n85 2523\n86 2551\n87 2557\n88 2594\n89 2600\n91 2622\n\nstr( birthwt[ \"bwt\" ] )\n\n'data.frame':   189 obs. of  1 variable:\n $ bwt: int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n\n\nHasználhatunk különféle módszereket (az alábbiak közül a második a logikai indexelés miatt fog működni):\n\nhead( birthwt[ , c( \"lwt\", \"smoke\" ) ] )\n\n   lwt smoke\n85 182     0\n86 155     0\n87 105     1\n88 108     1\n89 107     1\n91 124     0\n\nhead( birthwt[ birthwt$smoke==1, ] )\n\n    low age lwt race smoke ptl ht ui ftv  bwt\n87    0  20 105    1     1   0  0  0   1 2557\n88    0  21 108    1     1   0  0  1   2 2594\n89    0  18 107    1     1   0  0  1   0 2600\n94    0  29 123    1     1   0  0  0   1 2663\n95    0  26 113    1     1   0  0  0   0 2665\n100   0  18 100    1     1   0  0  0   0 2769\n\nhead( birthwt[ birthwt$smoke==1&birthwt$race==1, ] )\n\n    low age lwt race smoke ptl ht ui ftv  bwt\n87    0  20 105    1     1   0  0  0   1 2557\n88    0  21 108    1     1   0  0  1   2 2594\n89    0  18 107    1     1   0  0  1   0 2600\n94    0  29 123    1     1   0  0  0   1 2663\n95    0  26 113    1     1   0  0  0   0 2665\n100   0  18 100    1     1   0  0  0   0 2769\n\n\nAz adatkeret heterogén:\n\nbirthwt$nev &lt;- \"a\"\nhead( birthwt )\n\n   low age lwt race smoke ptl ht ui ftv  bwt nev\n85   0  19 182    2     0   0  0  1   0 2523   a\n86   0  33 155    3     0   0  0  0   3 2551   a\n87   0  20 105    1     1   0  0  0   1 2557   a\n88   0  21 108    1     1   0  0  1   2 2594   a\n89   0  18 107    1     1   0  0  1   0 2600   a\n91   0  21 124    3     0   0  0  0   0 2622   a\n\nstr( birthwt )\n\n'data.frame':   189 obs. of  11 variables:\n $ low  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ age  : int  19 33 20 21 18 21 22 17 29 26 ...\n $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...\n $ race : int  2 3 1 1 1 3 1 3 1 1 ...\n $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...\n $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...\n $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...\n $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n $ nev  : chr  \"a\" \"a\" \"a\" \"a\" ...\n\n\n\n\n2.3.5 Lista\nA lista heterogén, egydimenziós adatszerkezet.\nLegegyszerűbben elemei felsorolásával hozható létre, a list függvényt használva:\n\nlista &lt;- list( sz = szamvektor, k = karaktervektor, m = szammatrix, df = birthwt[ 1:5, ] )\nlista\n\n$sz\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n$k\n[1] \"a\"   \"b\"   \"xyz\"\n\n$m\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n$df\n   low age lwt race smoke ptl ht ui ftv  bwt nev\n85   0  19 182    2     0   0  0  1   0 2523   a\n86   0  33 155    3     0   0  0  0   3 2551   a\n87   0  20 105    1     1   0  0  0   1 2557   a\n88   0  21 108    1     1   0  0  1   2 2594   a\n89   0  18 107    1     1   0  0  1   0 2600   a\n\nstr( lista )\n\nList of 4\n $ sz: Named num [1:10] 4 1 99 NA NA NA NA NA NA 999\n  ..- attr(*, \"names\")= chr [1:10] \"egy\" \"ketto\" \"harom\" \"\" ...\n $ k : chr [1:3] \"a\" \"b\" \"xyz\"\n $ m : int [1:3, 1:2] 1 2 3 4 5 6\n $ df:'data.frame': 5 obs. of  11 variables:\n  ..$ low  : int [1:5] 0 0 0 0 0\n  ..$ age  : int [1:5] 19 33 20 21 18\n  ..$ lwt  : int [1:5] 182 155 105 108 107\n  ..$ race : int [1:5] 2 3 1 1 1\n  ..$ smoke: int [1:5] 0 0 1 1 1\n  ..$ ptl  : int [1:5] 0 0 0 0 0\n  ..$ ht   : int [1:5] 0 0 0 0 0\n  ..$ ui   : int [1:5] 1 0 0 1 1\n  ..$ ftv  : int [1:5] 0 3 1 2 0\n  ..$ bwt  : int [1:5] 2523 2551 2557 2594 2600\n  ..$ nev  : chr [1:5] \"a\" \"a\" \"a\" \"a\" ...\n\n\nSzámmal és – ha van neki – névvel is indexelhető:\n\nlista[[ 1 ]]\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\nlista$sz\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\nlista[[ \"sz\" ]]\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n\nAz egy zárójellel történő indexelés látszólag ugyanaz, de csak látszólag:\n\nlista[ 1 ]\n\n$sz\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\ntypeof( lista[[ 1 ]] )\n\n[1] \"double\"\n\ntypeof( lista[ 1 ] )\n\n[1] \"list\"\n\n\nTartomány is indexelhető:\n\nlista[ 1:2 ]\n\n$sz\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n$k\n[1] \"a\"   \"b\"   \"xyz\"\n\nlista[[ 1:2 ]]\n\n[1] 1\n\n\nAz előbbi dolgok természetesen kombinálhatóak is:\n\nidx &lt;- \"sz\"\nlista[[ idx ]]\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n\nAz adatkeret igazából egy, az oszlopokból - mint vektorokból - összerakott lista (tehát két szűkítés van: az elemek csak vektorok lehetnek és ugyanolyan hosszúaknak kell lenniük).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html#footnotes",
    "href": "adattipusokadatszerkezetek.html#footnotes",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "",
    "text": "Ez nem feltétlenül jelenti azt, hogy a programnyelv semmilyen ellenőrzést nem végez a tekintetben, hogy a típusokat helyesen kezeljük-e. Szoktak beszélni erősen és gyengén típusos nyelvekről a szerint, hogy mennyire szigorú ellenőrzéseket végez a programnyelv, de ezeket a fogalmakat nagyon sokféleképp definiálták, és nem egyértelmű, hogy mit jelentenek. Ha valaki azt mondja, hogy az R gyengén típusos, akkor valószínűleg arra gondol, hogy nagyon megengedőn és könnyedén konvertál különböző típusokat, implicite is, tehát ha nem mi írjuk konkrétan elő a konverziót – ezt később részletesen is fogjuk látni.↩︎\nEllenkező esetben a escape-elni kellene a dupla idézőjelet – egy elé írt backslash-sel, \\\" formában – különben az R nem tudhatná, hogy az nem a szöveg végét jelenti.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html",
    "href": "fuggvenyek.html",
    "title": "3  Függvények",
    "section": "",
    "text": "3.1 Paraméterátadás és visszatérési érték\nSok esetben előfordul, hogy egy statisztikai programban ismétlődő részek vannak. Tekintsük például a következő kódot (x egy valós számokat tartalmazó vektor):\nValószínűleg sokan felismerik, hogy ezzel az x-ben lévő elemek varianciáját számoltuk ki. Erre ezerszer szükség lehet egy statisztikai elemzésben: egyszer kiszámolhatjuk a testtömegek varianciáját, aztán a testmagasságokét, kellhet varianciát számolni, ha valamilyen regressziót futtatunk, ha főkomponens-elemzést hajtunk végre, egyszóval milliónyi feladatnál, akár ugyanazon szkripten belül is, pláne a különböző szkriptekben.\nMegtehetnénk természetesen, hogy minden ilyen esetben elhelyezzük ugyanazt a kódrészletet: kimásoljuk a fentit, és mindenhová beillesztjük, x-et a megfelelő változónévre cserélve – de remélhetőleg zsigerből érezhető, hogy ez nagyon-nagyon szerencsétlen megoldás lenne. Azon túl, hogy nagyon hosszúvá tenné a kódot (ami nem a gépnek probléma, hanem nekünk, olvashatóság szempontjából), azon túl, hogy megnehezíti a kód elemzését, értelmezését, mert nem lesz gyorsan és egyértelműen beazonosítható, hogy mely helyeken történik meg ez a számolás, a fő probléma, hogy borzasztóan megnehezítené a kód karbantartását, a hibajavításokat, fejlesztéseket. Képzeljük el például, hogy miután végeztünk a fenti bemásolgatós megoldással, észrevesszük, hogy az osszeg változót teljesen felesleges volt elmenteni, mert csak egyetlen egyszer hivatkozunk rá, nyugodtan beírhattuk volna közvetlenül a következő sorba. Mit csinálunk? Ha a bemásolgatós megoldással éltünk, akkor nincs más lehetőség, mind az ezer helyen át kell írni…!\nMennyivel jobb lenne ezt a kódot csak egyetlen egy helyen megírni, adni neki egy nevet, mondjuk variancia, és minden alkalommal, amikor szükség van rá a programunkban, azt írni ott, hogy „most futtasd le a variancia-t”. Egyetlen rövid utasítás, ami azt jelentené, hogy innentől ugorj át erre az – egyetlen helyen megírt – kódra, futtasd le, ami ott van, majd ha végeztél, térj vissza pontosan oda, ahol mondtuk, hogy futtasd le ezt a kód. Az ilyen kódot hívjuk úgy a programozásban, hogy függvény, az előbbi folyamatra pedig azt mondjuk, hogy meghívtuk a függvényt. Mindezt akárhány alkalommal megtehetjük, mindig ugyanaz az – egyetlen helyen megírt – függvény fut le, és a végén mindig oda ugrik vissza, ahonnan éppen hívtuk. A fenti kódot, a függvény „tartalmát” a függvény törzsének szoktuk mondani.\nEzzel a módszerrel sokkal olvashatóbb lesz a kód, azonnal és egyértelműen látszódni fog, hogy hol használtuk ezt a variancia-számítást, de a legfontosabb, hogy ha valamit módosítanunk kell a variancia-számításban, akkor ezt elég egy helyen megtenni, és ettől automatikusan az összes hívásnál meg fog változni.\nEgyetlen egy dolgot kell megoldani, az információk átadását. Mindkét irányban: valahogy el kell juttatnunk a függvényhez, hogy mi az a vektor, aminek a varianciáját számolni akarjuk, illetve fordítva, valahogy vissza kell juttatnunk a kiszámított varianciát a programhoz.\nAz előbbi megoldás kinézetét már sugallja a fenti kód is: a függvényben meghatározunk egy változónevet (x), és azon hajtjuk végre a műveleteket a függvény törzsében, az információátadást pedig úgy valósítjuk meg, hogy a függvény hívásakor megadjuk, hogy milyen konkrét érték, például programbeli változó – mondjuk testtomegek – kerüljön át a függvénybe ezen a néven. Az ilyen x-et szép néven paraméternek, a konkrét értéket, amit a függvény híváskor megadunk, argumentumnak nevezzük1; az egész mechanizmus neve pedig paraméterátadás. Lényegében az történik, hogy x szerepét a testtomegek változó fogja játszani – ennél a hívásnál. De később, ha meghívjuk a függvényt a testmagassagok argumentummal, akkor az fogja x szerepét játszani. Nekünk a függvényben azonban általánosan kellett meghatározni, hogy mit kell tenni, erre szolgál az x, azon írjuk le, hogy mi általában az eljárás, arról pedig az R gondoskodik, hogy ez mindig a megfelelő értéken hajtódjon végre. A háttérben az történik, hogy amikor meghívjuk a függvényt a testtomegek változóval mint argumentummal, akkor az R készít egy másolatot a testtomegek-ről, elnevezi x-nek, és lefuttatja rajta a függvény törzsét. A „készít róla másolatot” kitétel fontos, ez ugyanis azt is jelenti, hogy a függvény törzse bármit is csinál az x-szel, az nem fog visszahatni a hívó programban található testtomegek változóra: ha a függvény át is írja x-et, attól még a testtomegek a hívó programban ugyanaz marad (hiszen ilyenkor a függvény csak a testtomegek egy másolatát módosította, aminek semmi köze a testtomegek-hez!). Ezt szokták érték szerinti paraméterátadásnak nevezni2. Egyetlen megjegyzés a végére: ne ijedjünk meg a „készít róla másolatot” megfogalmazástól. Ezt csak az elmagyarázást segítő szófordulat volt a részemről, az R ezt igyekszik ügyesen kezelni, és nem feltétlenül készít3 ténylegesen másolatot, azaz a dolog nem jelenti automatikusan azt, hogy minden függvényhívásnál teljesítmény-veszteség keletkezik a másolgatások miatt, aminek van valamennyi időigénye.\nÉs mi a helyzet fordított irányban? Hogyan adhatunk vissza információt a hívó programnak? Az első dolog, amit tudni kell, hogy R-ben egy függvény csak egyetlen értéket adhat vissza4; ezt hívjuk visszatérési értéknek. Ez elsőre rosszul hangozhat, de ne ijedjünk meg, ez semmilyen érdemi limitációt nem jelent: a visszatérési érték ugyanis nyugodtan lehet egy lista is! Abba pedig akármilyen objektumból akármennyit bepakolhatunk. A visszatérési értéket megadni a return-nel lehet, a fenti példában azt kellene írnunk az utolsó sorban, hogy return(sum((x - atlag)^2)/(n - 1)). Ez azt jelenti, hogy a függvény végrehajtása befejeződik, a vezérlés visszakerül a hívó programhoz, olyan módon, hogy a függvényhívás behelyettesítődik a visszatérési értékkel. Ez utóbbi nagyon fontos: a dolgot úgy kell elképzelnünk, mintha a meghívott függvény helyébe odaírnánk a visszatérési értékét, és úgy menne tovább a végrehajtás. Két technikai megjegyzés a végére. Az egyik, hogy nem kötelező, hogy a return legyen egy függvény utolsó utasítása, de mivel a return elérésekor a vezérlés visszakerül a hívóhoz, így túl sok értelme sincs bármit utána írni. Jellemzően akkor fordul elő, hogy return-t látunk egy függvény közepén, ha valójában egy feltételes részben van, tehát nem biztos, hogy végrehajtódik: a return megvalósítja azt, hogy ha oda kerül a végrehajtás, akkor visszatér (és így a függvény többi része végre sem hajtódik), de ha nem, akkor a return le sem fut, és így mehet tovább a függvényben a végrehajtás. A másik megjegyzést talán még gyakrabban használjuk a gyakorlatban, ez pedig az a szabály, hogy ha a függvényben egyáltalán nincs return, akkor a visszatérési érték az utolsóként kiértékelt kifejezés értéke lesz. Ez a gyakorlatban azért fontos, mert elég tipikus, hogy egy függvény utolsó utolsó utasítása egyszerűen egy változó neve, vagy valamilyen egyszerű művelet egy változóval – ekkor ez az érték fog automatikusan return-ölődni. A fenti példában tehát igazából elég lenne a függvény utolsó sorában annyit írni, hogy sum((x - atlag)^2)/(n - 1), a return nem is kell, az eredmény ugyanaz lesz.\nHa egy függvény bármilyen más hatást vált ki azon kívül, hogy kiszámolja a visszatérési értéket és azt visszaadja, akkor azt mellékhatásnak nevezzük, az ilyen függvényt pedig mellékhatásos függvénynek. Ez elsőre meglepő lehet (mégis mi más hatása lehet egy függvénynek azon kívül, hogy kiszámolja a visszatérési értéket és azt visszaadja?!), de ha meggondoljuk, valójában egészen banális dolgok tartoznak ide – kezdjük például kapásból a kiíratással! Az ugyanis teljes mértékben egy mellékhatás: ha egy függvény hatására valami megjelenik a konzolon, annak nyilván semmi köze a visszatérési értékhez. De az is mellékhatás, ha egy fájlt kiírunk a merevlemezre, vagy mondjuk ha megjelenítünk egy ábrát. Az R programozási filozófiája miatt alapvetően kerülni célszerű a mellékhatásokat5, de mint az előbbi példák mutatják, bizonyos esetben elkerülhetetlenek.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html#saját-függvények-létrehozása",
    "href": "fuggvenyek.html#saját-függvények-létrehozása",
    "title": "3  Függvények",
    "section": "3.2 Saját függvények létrehozása",
    "text": "3.2 Saját függvények létrehozása\nA fentiekkel szinte már mindent tudunk ahhoz, hogy saját függvényt tudjunk definiálni. Amint láttuk, ez fontos: ez minden alkalommal jól jön, ha ismétlődő kódrészletek vannak a statisztikai számításunkban. Nézzük, hogyan tehetjük ezt meg egész pontosan.\nElőször is, függvényt ugyanúgy értékadással hozhatunk létre, ahogy létrehozunk egy – korábban még nem létező – változót. Amit a változónak értékül kell adnunk, az a function kulcsszó, ennek hatására a létrejövő változó egy függvény lesz, amit később meghívhatunk. A function után gömbölyű zárójel következik, benne a paraméterek – ennek részleteit a következő pontban fogjuk látni – utána pedig a függvény törzse. Ez egyetlen R kifejezés lehet, ami persze az esetek túlnyomó többségében értelmetlenül kevés, de semmi gond: erre szolgál a blokk-képzés. A blokk-képzés azt jelenti, hogy fogunk utasításokat, és összefogjuk őket egyetlen egységbe – ez lesz a blokk – amik úgy viselkednek, mintha az egyetlen kifejezés lenne. (A végrehajtása természetesen azt jelenti, hogy mindegyik benne lévő utasítás végrehajtódik egymás után, ahogy bármilyen R kódnál történne.) A blokk-képzés jele az R-ben a kapcsos zárójel, ezzel lehet több utasítást egyetlen blokkba összefogni.\nMindezek alapján egy saját függvény létrehozása a következőképp néz ki a fenti példában:\n\nvariancia &lt;- function(x) {\n  n &lt;- length(x)\n  osszeg &lt;- sum(x)\n  atlag &lt;- osszeg/n\n  sum((x - atlag)^2)/(n - 1)\n}\n\nEzután bármikor meghívhatjuk:\n\nx &lt;- rnorm(10)\nvariancia(x)\n\n[1] 0.4490108\n\n\n(Természetesen erre a célra van beépített – és a fentinél sokkal gyorsabb – függvény, a neve var, de ez most csak az illusztráció célját szolgálta.)\nAmi feltűnhet a fentiben, hogy sem a paraméterek, sem a visszatérési érték típusát nem kellett megadni. Ez következik abból, hogy az R dinamikus típusrendszerű nyelv, és minden igaz rá, amit a dinamikus típusrendszerről az adattípusoknál elmondtunk: egyszerűsíti az életet (nem kell vacakolni a típusok felsorolásával, nyugodtan előfordulhat, hogy az argumentumok fényében nem mindig ugyanolyan típusú eredményt adunk vissza), de cserében megszüntet egy védelmi vonalat, ami kinyit hibalehetőségeket. Nem csak arról van szó, hogy a fenti függvényt meghívhatjuk például egyelemű vektorral – ami az n-1-gyel való osztás miatt lesz elég nagy baj – de az előzőekben mondottak miatt még az ellen sem lesz beépített védelmünk, hogy valaki mondjuk egy szöveg varianciáját álljon neki kiszámíttatni…! Az R-ben minden ilyenre nekünk kell figyelni. És érdemes is: ilyen esetekben fontos lehet, hogy mielőtt bármit csinálunk, ellenőrizzük a kapott argumentumot vagy argumentumokat; erre vannak bevált eszközök és módszerek6 az R-ben. Ez különösen akkor helyes gyakorlat, ha a függvényt nem csak mi magunk fogjuk meghívni – ekkor még mondhatnánk, hogy a meghívó oldaláról tudjuk biztosítani a megfelelő argumentumokat, bár az igazság az, hogy ilyenkor is sokszor jobb a biztonság – hanem mások is meghívhatják, például, mert egy R csomagba kerül ki.\nAz R programozásáról szóló fejezetben látni fogjuk, hogy lesznek olyan függvények amelyeknek az egyik argumentuma maga is függvény. Ez lehet egy fentihez hasonló függvény: létrehozunk egy függvényt, nevet adunk neki, majd ezt a nevet adjuk meg ilyenkor argumentumként. Ilyen esetekben azonban elég gyakori, hogy a függvényt nem akarjuk külön elmenteni, saját néven, ugyanis máshol nincsen rá szükség, és csak ott akarnánk, direkte a kódba beleírni a függvényt az argumentum helyébe, anélkül, hogy előtte külön néven elmentjük. (Lényegében arról van szó, hogy szeretnénk megtenni ugyanazt a függvényekkel, amit megtehetünk más kifejezésekkel. Hiszen ha például gyököt akarunk vonni 3 + 1-ből, akkor egyáltalán nem kötelező előbb bementeni egy külön, névvel rendelkező változóba a 3 + 1-et, majd arra a változóra meghívni a sqrt-ot, egész nyugodtan megtehetjük azt is, hogy azt írjuk, hogy sqrt(3 + 1).) A helyzet az, hogy ez minden további nélkül működik függvényekkel is! A fenti szintaktikával kell létrehozni függvényt, de egyáltalán nem kötelező, hogy azt bármibe belenyilazzuk. Az így létrehozott függvény nyugodtan beírható az argumentum helyébe, a dolog tökéletesen működőképes lesz. Az ilyen függvényt hívjuk szép szóval anonim függvénynek.\nEgyetlen megjegyzés a végére. Az R 4.1.0-s verziója bevezetett egy rövidítést: a \\(x) pontosan ugyanaz mint a function(x). Ezt inkább anonim függvényeknél szokták használni, hiszen ott jobban mutat, ha kevesebbet kell írni, mivel ott a függvény egy másik függvény argumentumába van beírva, ami elég zsúfolt kódot eredményezhet már eleve is.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html#r-csomagok-használata",
    "href": "fuggvenyek.html#r-csomagok-használata",
    "title": "3  Függvények",
    "section": "3.3 R csomagok használata",
    "text": "3.3 R csomagok használata\nVolt már róla szó, hogy az R erejét nem kis részt az adja, hogy hihetetlen mennyiségű csomag érhető el hozzá, melyek a legkülönfélébb statisztikai problémák megoldását teszik lehetővé. Most már pontosabb definícióját adhatjuk annak, hogy mi az egyáltalán, hogy R csomag: tartalmilag összetartozó függvények gyűjteménye (dokumentációval és esetleg adatokkal kiegészítve). Nézzük meg részletesebben, hogy miről van szó!\nAmikor azt mondtam, hogy „statisztikai problémák megoldása”, akkor azt lényegében így értettem: megfelelő függvények megírása. Hiszen ezeket a statisztikai problémákat éppen úgy oldjuk meg, hogy létrehozunk (egy vagy több) függvényt! A megoldás abban manifesztálódik, hogy létrehozunk függvényt vagy függvényeket, amik a szükséges számításokat elvégzik, tehát tömörítik a statisztikai tudásunkat azáltal, hogy a feladatot – vagy valamilyen részfeladatát – megoldják, ahogy a fenti függvény megoldja a variancia kiszámításának a feladatát. Azzal a nem elhanyagolható eltéréssel, hogy a függvény természetesen nem biztos, hogy 4 sor, lehet éppenséggel 4 ezer is. Elég tipikus, hogy egy adott témakör számításai több függvényt igényelnek, ezeket dokumentációval kell ellátni, néha érdemes adatbázisokat is mellékelni – az R csomag nem más, mint ilyenek gyűjteménye. Amikor betöltünk egy R csomagot, akkor elérhetővé válnak a benne definiált függvények, vagyis azáltal „férünk hozzá az erejéhez”, hogy meg tudjuk hívni ezeket a függvényeket, így egyetlen sorban elérünk néha több ezer sornyi, adott esetben igen komplex statisztikai számítást, amit más, jó esetben a témában jártas szakértők megírtak számunkra, így mi készen használhatjuk.\nKis kitérő: eddig még nem töltöttünk be semmilyen csomagot, és mégis voltak elérhető függvényeink, mint az rnorm vagy a épp az str. Eddig ezt úgy kezeltem, mintha ezek valamiféle „beépített” függvények lennének, amikhez nem kell csomagot betölteni… csakhogy ez nem igaz. Ezek szintén csomagban vannak, ugyanúgy mint bármely más függvény (általában is, ha megnézzük egy függvény súgóját, akkor a bal felső sarokban, kapcsos zárójelben látjuk, hogy melyik csomagban, innen kiderül, hogy az rnorm a stats-ban, az str a utils-ban van), és ezeket a csomagokat nagyon is be kell tölteni, hogy elérjük a függvényeiket – csak épp az R ezt megteszi helyettünk! Van ugyanis hét csomag7 amit az R az indulásakor automatikusan betölt, így a függvényei elérhetővé válnak úgy, hogy látszólag nem kellett semmit sem tennünk – de a valóságban ez is ugyanúgy csomagbetöltés volt.\nMég mielőtt a csomagok betöltésére térünk, egy dolgot meg kell beszélni: a csomagok telepítését, betölteni ugyanis csak telepített csomagot8 tudunk. Bárki készíthet R csomagot, egy R csomag lehet egyetlen összecsomagolt zip-fájl, de van egy eszköz, ami miatt mégsem alakul ki káosz ebből a dologból, azaz nem zip-fájlok keringenek össze-vissza, ez az eszköz pedig nem más, mint a CRAN (Comprehensive R Archive Network). Ez az R csomagok egy központi repozitóriuma, ahol szinte minden fontos R csomag megtalálható, így ez kiküszöböli a káoszt: szinte mindenki erre az egy helyre tölti fel az R csomagját, ha készít ilyet, és szinte mindenki erről az egy helyről tölti le az elkészített R csomagokat. (A „szinte” kitétel annak szól, hogy léteznek más repozitóriumok is, megfelelő csomag segítségével lehet Github-repozitóriumból is installálni csomagot, illetve elvileg lehet tényleg zip-fájlból is telepíteni csomagot, de ezek jelentősége eltörpül a CRAN mellett.) A CRAN ráadásul ellenőrzi is a csomagot, egyébként elég szigorúan, tehát ez egyfajta minőségbiztosítás is. (Mindazonáltal az ellenőrzés formai, tehát a csomag szintaktikai helyességére vonatkozik, nem a statisztikai – vagy bármilyen más – tartalmának tudomány helyességére!) A CRAN-ről történő telepítéshez az R külön utasítást tartalmaz, így valójában nem kell semmilyen zip-fájl letöltéssel vesződnünk. Ha RStudio-t használunk, akkor választhatjuk egyszerűen a Tools menü Install packages pontját, itt alapértelmezett a CRAN-ről történő telepítés, így csak a csomag nevét – vagy több csomag esetén a neveiket, vesszővel elválasztva – kell megadni, ebben automatikus kiegészítés segít is, majd az Install gombra kattintva megtörténik a telepítés. A konzolon láthatjuk, hogy ez igazából egyenértékű az install.packages függvény meghívásával, argumentumként megadva a csomag nevét; válaszhatjuk ezt a megoldást is. (Viszont ezt nem illik magába a szkriptbe beleírni, mert ez azt jelentené, hogy ha az egész szkriptet egyben futtatjuk, akkor az minden alkalommal nekiáll telepíteni a csomagot.) Ha egyszer megtörtént a telepítés9, onnantól már betölthetjük a csomagot.\nHogy legyen egy konkrét példánk csomag betöltéséhez, tekintsük azt a feladatot, hogy szeretnénk 10 véletlenszámot generálni, de ezúttal egy standard inverz exponenciálisnak nevezett eloszlásból. Hogy mi ez az eloszlás, az most mindegy is, ami viszont fontos, hogy – szemben a normálissal – az R erre nem tartalmaz „beépített” függvényt. De semmi vész, szerencsére az actuar nevű csomagban van egy függvény, a neve rinvexp, ami pont ezt valósítja meg! Első pont: ha korábban nem tettünk meg, telepítenünk kell az actuar csomagot; e nélkül nem tudunk továbbhaladni. Második pont: ha telepítettük, akkor be kell tölteni.\nEzen a ponton kettéágaznak a lehetőségek. Még mielőtt belevágunk, elsőként állapítsuk meg, hogy betöltés nélkül nem tudjuk lefuttatni a függvényt, hibát fog adni:\n\nrinvexp(10)\n\nError in rinvexp(10): could not find function \"rinvexp\"\n\n\nAz első lehetőség, hogy a :: (két kettőspont, néha szokták magyarul négyespontnak is hívni) operátort használjuk: először leírjuk a csomag nevét, utána négyespontot teszünk, majd a függvény nevét a csomagból. Jelen esetben:\n\nactuar::rinvexp(10)\n\n [1]  1.3094559  1.0060341  1.7088120  0.4288881  1.1433986  1.5080163\n [7]  0.4461239 98.2886329  3.5628782  4.8587025\n\n\nMagyarra lefordítva az actuar::rinvexp praktikusan azt jelenti, hogy „az actuar csomag rinvexp nevű függvénye”.\nEz nem szó szerint a csomag betöltése, abban az értelemben, hogy ettől nem válik a csomag összes többi függvénye elérhetővé, csak ez az egy (és ez is csak ekkor, ha később újra szükségünk van erre a függvényre, akkor megint elé kell írni, hogy actuar::). A csomag szó szerinti betöltését a library függvénnyel10 hajthatjuk végre:\n\nlibrary(actuar)\n\n\nKapcsolódás csomaghoz: 'actuar'\n\n\nThe following objects are masked from 'package:stats':\n\n    sd, var\n\n\nThe following object is masked from 'package:grDevices':\n\n    cm\n\n\nHa ezt megtettük, akkor onnantól nincs szükség a :: operátorra, a csomag valamennyi függvénye automatikusan, minden előtag nélkül elérhetővé válik! Azaz innentől működik ez a megoldás is:\n\nrinvexp(10)\n\n [1] 3.3288829 1.1386131 0.7429031 4.2753939 0.5375839 0.6410861 0.9227024\n [8] 5.5910164 7.5977964 0.5318674\n\n\nEgy apró megjegyzés a teljes precizitás kedvéért. A négyespont operátor csak azokat a függvényeket teszi elérhetővé, amik ún. exportált függvényei a csomagnak. Az exportálás lényegében azt jelenti, hogy elérhetővé akarjuk-e tenni az adott csomagbeli függvényt. Ez elsőre meglepő lehet (miért raknánk egy függvényt egy csomagba, ha nem akarjuk elérhetővé tenni?!), de elképzelhetőek helyzetek, ahol ennek van értelme, például, mert csak egy belső célokat szolgáló segédfüggvényről van szó – az ilyeneknek lehet szerepe, a felhasználó számára is, mert más csomagbeli függvények meghívhatják, csak közvetlenül nem lehet őket kívülről meghívni. Ha valami oknál fogva mégis ezt szeretnénk, akkor a ::: operátort kell használni, ezzel nem exportált függvény is hívható.\nA nyitva maradt kérdés, hogy melyik a jobb megoldás, a :: használata vagy a library-vel történő betöltés? A válaszhoz egy dolgot kell még tudni, azt, hogy mi történik akkor, ha a csomagban van egy olyan nevű függvény, ami már létezik. Hiszen minden további nélkül lehet egy rnorm nevű függvény definiálva egy csomagban! (Vagy akár két különböző csomagban.) A helyzet az, hogy ilyenkor, ha betöltjük a csomagot library-vel, akkor felülíródik a csomag függvényével a korábban már létező, ugyanolyan nevű függvény. Ha betöltünk később egy másik csomagot is library-vel, amiben van ugyanolyan nevű függvény, akkor meg azzal íródik felül. Az rnorm kicsit extrém példa, de mondjuk filter nevű függvény tényleg tömegével van különféle csomagokban. A dolog tehát egy olvashatósági problémát fog okozni: ha egyszerűen annyit látunk egy kódsorban, hogy filter(x), akkor nem tudhatjuk, hogy ez minek a filter-je, melyik csomag filter nevű függvénye fog itt lefutni. A „beépített” filter? (Mert van ez is; igazából a stats csomagé.) A dplyr csomag filter-je? A signal csomag filter-je? A seewave csomag filter-je? A legrosszabb, hogy ezt nem is lehet megmondani pusztán ebből a kódsorból – mert azon fog múlni, hogy melyik csomagot töltöttük be utoljára! Tehát ezt csak úgy tudjuk eldönteni, ha visszamegyünk a kódban (akár több száz vagy ezer sort is adott esetben), megnézzük az összes library hívást, hogy definiál-e filter-t, és ez fogja eldönteni, hogy a kérdéses sorban pontosan mi is fut: a beépített filter vagy valamelyik csomagé? Ha több, filter-t definiáló csomagot is betöltünk library-vel, akkor még az is számítani fog, hogy milyen sorrendben töltjük be őket! Emiatt célszerűbb, ha ahol lehet, inkább a :: operátort használjuk. Ennek az egyetlen hátránya11, hogy többet kell hozzá írni, és ha nagyon sokszor ismétlődik, az zavaró lehet, így végeredményben az ajánlás az, hogy library-vel csak azokat a csomagokat töltsük be, amik alapvetőek, amik függvényeit sokszor és intenzíven használjuk – a többi esetében jobb a :: használata.\nEgyetlen megjegyzés a végére: néha érdemes a csomagokat frissíteni! Hiszen a csomagok frissülnek a CRAN-en, ha a szerzőjük feltölt egy újabb változatot, de az nem kerül át automatikusan a gépünkre. Ezért érdemes rendszeresen megnyomni RStudio-ban a Tools / Update packages pontot, és az összes csomagot frissíteni. (Egyébként végeredményben ez is az install.packages-t fogja meghívni.)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html#függvények-specifikációja-és-meghívása",
    "href": "fuggvenyek.html#függvények-specifikációja-és-meghívása",
    "title": "3  Függvények",
    "section": "3.4 Függvények specifikációja és meghívása",
    "text": "3.4 Függvények specifikációja és meghívása\nFüggvény úgy hívható meg, hogy megadjuk a nevét, majd utána gömbölyű zárójelben az argumentumát, vagy argumentumait:\n\nrnorm(10)\n\n [1] -1.3671543 -1.0948228 -1.1728681  0.1706927 -1.3001507  0.2039052\n [7] -1.8319464 -1.9778997  0.9909998 -0.6888811\n\n\nElképzelhető, hogy egy függvénynek egy argumentuma sincs, de a zárójelet ekkor is ki kell írni (azonnal becsukva, értelemszerűen). Ez fontos, ugyanis zárójel nélkül beírva a függvény nevét az R kiírja a függvény törzsét:\n\nrnorm\n\nfunction (n, mean = 0, sd = 1) \n.Call(C_rnorm, n, mean, sd)\n&lt;bytecode: 0x00000205f3f5f998&gt;\n&lt;environment: namespace:stats&gt;\n\n\nFüggvényről súgó a kérdőjellel kapható: ?rnorm. Ez a megoldás akkor használható, ha a függvény pontos nevét tudjuk, mert azt kell a kérdőjel után írni, ha nem tudjuk a pontos nevet, csak a név egy töredékét, akkor a két kérdőjel (??rno) használható; ez végigkeresi az összes súgó-oldalt a beírt töredék után, és listát ad róluk12.\nAmi nekünk most különösen fontos a súgóban, az a függvény ún. specifikációja. (Ha saját magunk írtuk a függvényt, akkor ezt a specifikációt mi magunk kellett hogy megadjuk – ahogy az az előző pontban szerepelt is.) Az rnorm esetén ez a következőképp néz ki:\nrnorm(n, mean = 0, sd = 1)\nAz argumentumok az args függvénnyel is megtudhatóak:\n\nargs(rnorm)\n\nfunction (n, mean = 0, sd = 1) \nNULL\n\n\nEbben a következő elemek láthatóak:\n\nA függvény neve, esetünkben az rnorm. Utána, ahogy már volt róla szó, gömbölyű zárójelben következnek az argumentumok.\nSzintén volt róla szó, hogy az argumentumok száma tetszőleges lehet, a nullát is beleértve; jelen esetben a függvénynek három argumentuma van.\nMinden argumentumnak van egy neve, kötelező is, hogy legyen. Ez esetben az első argumentum neve n, a másodiké mean, a harmadiké sd.\nEgy argumentumnak lehet, de nem kötelező, hogy legyen ún. alapértelmezett értéke; ha van, akkor egyenlőségjel után szerepel az argumentum neve után. Esetünkben az n nevű argumentumnak nincs alapértelmezett értéke, a mean-nek és az sd-nek van, az előbbinek 0, az utóbbinak 1.\n\nTermészetesen nagyon fontos, és a súgó többi részéből ez ki is derül, hogy egyáltalán mit csinál a függvény, mire jó, mi a tartalma az egyes argumentumoknak, mi a visszatérési értéke, de mi most fókuszáljunk a szintaktikára.\nKezdjük ott, hogy ha egy argumentumnak van alapértelmezett értéke, akkor azt az argumentumot nem kötelező megadni a hívás során, viszont aminek nincs, azt kötelező. Ezért van az, hogy az rnorm(10) lefut, noha csak egy argumentumot adtunk meg (mert a másik kettőnek van alapértelmezett értéke), viszont ha az n-et nem adjuk meg, akkor hibát ad a függvényhívás:\n\nrnorm()\n\nError in rnorm(): argument \"n\" is missing, with no default\n\n\nAz alapértelmezett értékkel rendelkező argumentumokat tehát nem kötelező megadni, de természetesen lehet:\n\nrnorm(n = 10, mean = 70, sd = 15)\n\n [1] 55.24682 54.73842 81.86988 40.15497 81.11896 70.22852 82.66430 62.31893\n [9] 68.76881 53.73924\n\n\nMint látható, argumentumot úgy adunk meg a hívás során, hogy beírjuk a nevét, egyenlőségjelet teszünk13, majd utána leírjuk az értékét. Ami fontos, hogy a nevek elhagyhatóak, ez esetben az R abban a sorrendben rendeli hozzá a beírt értékeket az argumentumokhoz, amilyen sorrendben a specifikációban szerepelnek14. Vagyis a fenti hívás egyenértékű ezzel:\n\nrnorm(10, 70, 15)\n\n [1] 55.80897 60.26745 68.15745 84.57743 74.30222 93.38351 74.34811 68.06644\n [9] 65.80752 61.73500\n\n\nEzt voltaképp már korábban is láttuk: az rnorm(10) ezért működött minden név megadása nélkül is.\nA nevek megadása lehetővé teszi, hogy más sorrendben soroljunk fel argumentumokat, mint a specifikációban szerepelnek:\n\nrnorm(sd = 15, n = 10, mean = 70)\n\n [1]  98.79727  66.90216  75.55330  83.62050  70.40793  39.02675  67.60809\n [8] 100.45886  58.87625  49.26383\n\n\nVagy, hogy átugorjunk egy argumentumot:\n\nrnorm(10, sd = 15)\n\n [1]  12.9350850  11.6353365 -13.8677858  21.4341684 -19.2727692  -0.3772007\n [7]  11.9600289  -4.0939502  16.3328792  -6.1456667\n\n\nAz R-es gyakorlat az, hogy az első néhány, mondjuk 3-4 argumentumtól eltekintve akkor is írjuk ki a neveket, ha egyébként sorrendben adtuk meg őket a hívás során. Ennek nem a kód futtathatóságához, hanem az olvashatóságához van köze: átlagos R-hez értő embertől elvárható, hogy – különösen a gyakran használt függvényeknél – az első néhány argumentumról tudja, hogy mi a jelentésük, de a továbbiakról már nem feltétlenül, így az olvasónak segítség, ha ezeknél feltüntetjük a nevet, még akkor is, ha az R-nek nem kellene, mert sorrendben jönnek. Ez azért van így, mert ezek általában beszélő nevek (ez az rnorm példáján is jól látszik!); ha majd mi magunk definiálunk függvényt, akkor is törekedjünk rá emiatt, hogy mi is ilyen beszélő neveket adjunk.\nEgy utolsó dolgot kell még a fentiek kapcsán megbeszélnünk. Az eddigi leírásból úgy tűnhet, hogy a függvényeknek mindig adott, rögzített, előre ismert számú argumentumuk van – annyi, amennyit a specifikációban felsoroltunk. Az eddigi példákban ez valóban így volt, de gondoljunk bele, mi a helyzet mondjuk a c-vel? (Eddig nem mondtam, de természetesen ez is egy függvény!) Hogyan lehetséges, hogy működik a c(1, 2) és a c(1, 2, 3) is? A válasz az, hogy az R megenged egy speciális argumentumot, a három pontot15: a c függvény specifikációja úgy néz ki, hogy c(...). A három pont azt jelenti: tetszőleges számú argumentum. Ilyen esetben tehát azt mondjuk, hogy mi magunk sem tudjuk, hogy hány argumentumot kapunk, minden teljesen azon múlik, hogy a felhasználó hogyan hívja meg a függvényt – ami szerepel a meghívásban, az fog átkerülni a ... alatt, legyen az 0 argumentum, 1, vagy 100. A felhasználó megteheti, hogy a ... helyén 0 argumentumot ír be a függvény meghívásakor, megteheti, hogy 1-et, megteheti, hogy 100-at. (Ha majd saját függvény írunk: ilyenkor a függvényen belül szintén ... névvel hivatkozhatunk arra, hogy mit kaptunk a hívás során. Annyit kell tudni erről, hogy ez egy elég speciális elem, első lépésben szinte mindig listává alakítjuk: list(...) már egy szokásos lista lesz, amit innentől a hagyományos módon, megszokott listaként használhatunk.) A ...-ban átadott argumentumoknak lehet neve, de ez nem kötelező. A ... vegyíthető a „szokásos” argumentumokkal: egy függvénynek nézhet úgy ki a specifikációja, hogy f(x, ..., y = 1, z = 2). Ez azt jelenti, hogy az első egy kötelező argumentum, x névvel, utána jön tetszőleges, és előre nem ismert számú argumentum (akár 0 is): hogy itt mit kap a függvény, az teljesen azon múlik, hogy a felhasználó hogyan hívja meg. Ezután egy y nevű argumentum következik 1 alapértelmezett értékkel, végül egy z nevű 2 alapértelmezett értékkel. Ennek megfelelően az f(1) esetén az x értéke 1 lesz, a list(...) egy üres lista, y pedig 1 , míg z értéke 2. Az f(1, z = 10) annyiban tér el ettől, hogy z értéke 10 lesz. Végezetül az f(1, 2, a = 3, 4, z = 10) hívásnál x értéke 1 lesz, a list(...) egy háromelemű lista lesz 2, 3 és 4 értékekkel (amiből a középsőnek a a neve, a másik kettőnek nincs neve), y értéke 1, z értéke 10. (Mint látható, ilyenkor, ha y-nak vagy z-nek szeretnénk beállítani az értékét, akkor kötelező megadni a nevét a hívásban, különben az R azt hinné, hogy a megadott argumentum a ... része.)\nZárásként még egy apróság: bizonyos esetekben felmerül a kérdés, hogy mi a teendő akkor, ha úgy kell egy függvényt meghívnunk, hogy mi magunk sem tudjuk előre (tehát a programkód írásakor) az argumentumait, például mert egy másik függvény állítja elő. Ilyenkor célszerű ezeket egy listába helyezni, az R ugyanis kínál egy megoldási lehetőséget erre:\n\nfuggvenyargs &lt;- list(n = 10, mean = 70, sd = 15)\ndo.call(rnorm, fuggvenyargs)\n\n [1] 58.03218 62.64565 63.21657 71.30185 63.94835 41.67665 86.98282 57.68927\n [9] 46.08005 85.83567\n\n\nA do.call tehát meghívja az első argumentumban megadott függvényt a második argumentumban megadott argumentumokkal. A do.call lényegében elválasztja egymástól a függvény nevét és argumentumait (ami az rnorm(sd = 15, n = 10, mean = 70) típusú hívásnál össze van gubancolódva); ezzel megoldást adva a fentiekben említett helyzetre is. Ha a függvény argumentumai között ... van, a do.call akkor is működik, vagyis az átadott lista hossza nem kötelező, hogy mindig ugyanaz legyen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html#footnotes",
    "href": "fuggvenyek.html#footnotes",
    "title": "3  Függvények",
    "section": "",
    "text": "Az R a paramétert formális argumentumnak hívja; ezt a szóhasználatot egyébként a magyar szaknyelv is megengedi mint a paraméter szinonimája. De sokszor nem vesződnek ezzel a különbségtétellel, és egyszerűen argumentumot mondanak.↩︎\nAz alternatívája a cím szerinti paraméterátadás, ami nagyon leegyszerűsítve az, ha a függvény nem a változó egy másolatát kapja meg, hanem azt a memóriacímet, ahol a változó van. Ez más, mert bár kiolvasva a memóriacímet megkapjuk a változó tartalmát, ugyanúgy mint az érték szerinti átadásnál, viszont a memóriacím ismeretében akár módosíthatjuk is azt: ha valamit átírunk ott, az módosítja a hívó program számára is a változót. Cím szerinti átadáshoz hasonló mechanizmus megvalósítható R-ben is, de külön erőfeszítést igényel, az alapvető működési mód az R-ben az érték szerinti átadás. A valóságban az érték és cím szerinti átadásnak sok egyéb finomsága van, más paraméterátadási módok is léteznek, de ezek számunkra nem lesznek most fontosak.↩︎\nEzt hívják copy-on-modify mechanizmusnak, ez szabályozza, hogy mikor készül másolat, és ha nem készül, akkor hogyan oldja meg a paraméterátadást.↩︎\nÉs az érték szerinti paraméterátadás miatt argumentumot sem használhatunk információ visszajuttatására, ahogy az más nyelvben előfordulhatna.↩︎\nEzen a ponton visszatérhetünk egy pillanatra arra a korábbi megállapításra, hogy egy függvény lecserélhető a visszatérési értékére. Ha ez megvalósul, akkor azt mondjuk, hogy fennáll a hivatkozási átlátszóság; ennek a feltétele, hogy a függvény mellékhatásmentes legyen, és adott argumentumokra mindig, determinisztikusan ugyanazt a visszatérési értéket szolgáltassa. Az ilyeneket tiszta függvénynek szokták hívni a programozáselméletben.↩︎\nLegegyszerűbb esetben használhatjuk a stopifnot függvényt, de van külön csomag is erre a célra, például az assertthat vagy a checkmate.↩︎\nA base, a stats, a methods, a graphics, a grDevices, a utils és a datasets. Egész pontosan az a mechanizmus, hogy a base csomag mindenképp betöltődik induláskor, utána pedig azok töltődnek még be ezen felül automatikusan, amik a defaultPackages nevű opcióban szereplnek; az előbbi lista ennek az alapértelmezését tükrözi.↩︎\nAz R szokásos installációja a korábban említett, induláskor automatikusan betöltődő csomagokon kívül még kb. egy tucatnyi csomagot telepít, tehát ezeket be kell ugyan kézzel tölteni, de külön telepíteni nem kell. Ezen kívül minden más csomagot először telepíteni kell.↩︎\nEgyetlen megjegyzés ehhez. A CRAN-en a csomagok fent vannak forráskóddal, illetve Windows-ra előre lefordított (binary) verzióban is. Ez azt jelenti, hogy Linux-on a CRAN-ről történő telepítés mindenképp a forráskód fordítását fogja jelenteni, Windows-on viszont nem feltétlenül. Néha azonban az a helyzet, hogy a forráskódú verzió frissebb, mint a lefordított; ilyenkor a Windows-on is jól jöhet a forráskódból fordítás. Ehhez azonban fordítóeszköz fog kelleni! Szerencsére ehhez van kész eszköztár az R-hez, a neve RTools, érdemes telepíteni.↩︎\nEnnek van egy alternatívája, a require függvény. A kettő nagyon hasonlít egymásra, az egyetlen különbség akkor bukik ki, ha nem telepített könyvtárat akarunk betölteni: ekkor a library hibát ad, a require csak figyelmeztetést, és visszatérési értékként FALSE-ot (sikeres betöltés esetén ezzel szemben TRUE-t). Ebből következik, hogy interaktív munkamenetnél – magyarán, ha kézzel pötyögünk, meg hajtatunk végre kódsorokat – a library tökéletes, viszont ha csomag-betöltést egy futó program maga végzi, akkor a require jobb lehet, mert gépi úton tudjuk kezelni a helyzetet, hogy volt-e az adott gépen telepítve a csomag, sikerült-e betölteni, és ennek fényében továbbmenni. De vigyázat: ha ezt a kezelést nem hajtjuk végre, akkor a require veszélyes lehet, mert azt okozhatja, hogy a futás nem áll meg azonnal, és csak később – praktikusan amikor az adott könyvtárból akarunk egy függvényt hívni – lesz baj, amit viszont így nehezebb lesz beazonosítani, hogy mi okoz. Mivel azonban egy csomag elérhetőségének az ellenőrzésére van más megoldás, a requireNamespace függvény, így van, aki azt javasolja, hogy require-t egyáltalán ne használjunk.↩︎\nElvileg egy nagyon minimális teljesítmény-veszteséget jelent a :: (mivel a háttérben egy függvényhívást jelent igazából), de ennek valószínűleg semmilyen gyakorlati esetben nem lesz érdemi jelentősége: én most tettem egy próbát, az actuar::rinvexp(10) medián futásideje a gépemen 1,9 \\(\\mu\\)s, az actuar csomag library-vel betöltése után az rinvexp(10)-é 1,6 \\(\\mu\\)s. Egy fokkal talán nyomósabb érv lehet a library mellett, hogy ha a szkriptünket azzal kezdjük, hogy az összes használt csomagot be-library-zzük, akkor egyrészt azonnal látszik, hogy mikre lesz szükség, másrészt, ha valamelyik nincs meg a futtató felhasználó gépén, akkor az rögtön az elején kiderül a hibából. A library-k használata nélkül ez csak az első ::-nál bukna ki, ami nem elegáns: általános programtervezési elv, hogy ha valami baj van, akkor jobb, ha az minél előbb kiderül.↩︎\nEz a helyi gépen keres, ebből fakadóan természetesen csak azokat a csomagokat tudja végigkeresni, amik telepítve vannak helyileg. Létezik három kérdőjeles változat (???rno) is, ami az R központi weboldalán keres, így – többek között – valamennyi csomagot végignézi, függetlenül attól, hogy helyileg telepítve van-e. Ez azonban egy külön csomag, az sos telepítését igényli (a három kérdőjel ugyanis igazából nem más, mint egy hozzárendelt rövidítés, ún. alias az sos::findFn függvényhez, ami ilyen keresést hajt végre).↩︎\nAz értékadásnál említettem, hogy a nyíl helyett szinte felcserélhetően használhatnánk egyenlőségjelet is, és hozzátettem, hogy az R-es szokás az, hogy az egyenlőségjelet másra használjuk. Akkor most már elárulhatom: erre! A szokás az, hogy az értékadásnál nyilat írunk, függvény argumentumának megadásakor egyenlőségjelet. A kettő között a különbség minimális.↩︎\nHogy teljesen precíz legyek, az algoritmus a következő: először fogja az elnevezett argumentumokat, és megkeresi, hogy pontosan olyan névvel van-e paraméter, ha igen, akkor megfelelti őket egymásnak. Ha marad még hívásban szereplő argumentum, aminek nem feleltetett meg paramétert, akkor tovább megy: ezt követően – és ez meglepő lehet – részleges egyezéseket is keres az elnevezett argumentumok között: megnézi, hogy van-e olyan, ahol a hívásban szereplő név egyezik a paraméter nevének az elejével. Például ha a hívásban atl néven hivatkozunk egy argumentumra az át fog adódni az atlag paraméternek (feltéve, hogy nem adtunk át atlag nevű argumentumot is, mert az az első lépésben már „megenné” az atlag nevű paramétert). Végezetül, ha még így is van nem összerendelt argumentum és paraméter, akkor az összes megmaradt argumentumot sorrendben osztja ki a megmaradt paramétereknek.↩︎\nAngolul a neve ellipsis; semmi köze az ellipszishez, egyszerűen arról van szó, hogy angolul, mármint a nyelvészetben, így hívják a – tipikusan mondat végi – három pontot. Az R nemes egyszerűséggel „dot-dot-dot”-nak is hívja.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "programozas.html",
    "href": "programozas.html",
    "title": "4  Az R programozása",
    "section": "",
    "text": "Programozás.\n\ndata(birthwt, package = \"MASS\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Az R programozása</span>"
    ]
  },
  {
    "objectID": "datatable.html",
    "href": "datatable.html",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "",
    "text": "5.1 Sebesség és nagyméretű adatbázisok kezelése\nAmint volt már róla szó korábban, az adatkeret (data frame) az alapvető struktúra a feldolgozandó adatok, adatbázisok tárolására és kezelésére az R-ben. Noha ennek a célnak megfelel, számos téren kiegészíthető, továbbfejleszthető. Az évek alatt két nagy lehetőség kristályosodott ki és ment át széleskörű használatba, mely ilyen továbbfejlesztést jelent: a dplyr csomag és a data.table csomag. Jelen fejezet a data.table működését és jellemzőit fogja bemutatni, különös tekintettel a hagyományos data frame-mel való összevetésre.\nA data.table csomag első verziója 2008-ban jelent meg, eredeti megalkotója Matt Dowle. Nagyon erőteljes, gyors, erősen optimalizált, némi gyakorlás után logikus, kompakt, konzisztens, könnyen lekódolható és jól olvasható szintaktikájú, jól támogatott csomag. A data.table-nek semmilyen függősége nincs az R-en kívül (ott is törekednek a nagyon régi változatok támogatására is), így kifejezetten problémamentesen beépíthető R kódokba, csomagokba.\nKözponti weboldala: https://rdatatable.gitlab.io/data.table/. Github-oldala: https://github.com/Rdatatable/data.table. CRAN-oldala: https://cran.r-project.org/web/packages/data.table/index.html.\nA data.table mint csomag egy azonos nevű új adatstruktúrát definiál; ez lényegében egy „továbbfejlesztett data frame”. Ez az új adatstruktúra, a data table egyrészt olyan lehetőségeket biztosít, amik valamilyen módon megvalósíthatóak lennének szokásos data frame-mel is, de csak lassabban/nehézkesebben/több hibalehetőséggel, másrészt elérhetővé tesz olyan funkciókat is, amik data frame-mel egyáltalán nem megoldhatóak.\nA következőkben át fogjuk tekinteni ezek legfontosabb példait.\nA gyakorlati szemléltetésekhez töltsük be a könyvtárat (a data.table nem jön az alap R installációval, így ha korábban nem tettük meg, elsőként telepíteni kell):\nEbben a fejezetben a magyar Nemzeti Rákregiszter adatait fogjuk példa adatbázisnak használni.\nElsőként töltsük be a következő fájlt, ami eleve data.table formátumban tartalmazza az adatokat:\nNéhány esetben össze fogjuk vetni a data.frame-et a data.table-lel, ehhez „minősítsük vissza” az adatbázist data frame-mé, és ezt mentsük el egy új változóba:\nÉrdemes ránézni egy data table felépítésére:\nAmi feltűnhet, hogy az objektumnak egyaránt van data.table és data.frame osztálya, egyebekben azonban a fenti információk megfelelnek egy data frame által mutatott felépítésnek. A két osztály jelenléte egyfajta visszafele kompatibilitást1 jelent: egy data table olyan számítógépen is betölthető, ahol nincs data.table csomag, és működni fog (természetesen csak mint hagyományos data frame). Ezen túl az is igaz ennek következtében, hogy olyan függvénynek, ami data.frame-et vár mindig átadható data.table is.\nVisszatérve a tábla felépítésére, a fentiek alapján már elmondható, hogy a tábla mit tartalmaz: az új rákos esetek előfordulását Magyarországon évenként (2000-től 2018-ig), megyénként, nemenként, életkoronként (ez 5 éves felbontású, tehát a 40 igazából azt jelenti, hogy „40-45 év”), és a rák típusa szerint. Ez utóbbi ún. BNO-kóddal van megadva: a Betegségek Nemzetközi Osztályozása (BNO, angol rövidítéssel ICD) egy nemzetközileg egységes rendszer, mely minden betegséghez egy kódot rendel. A kód első karaktere egy betű, ez a főcsoport; a rákos betegségek a C főcsoportban, illetve a D elején vannak, a második és harmadik karakter egy szám, ami konkrét betegséget vagy betegségcsoport azonosít; például C00 az ajak rosszindulatú daganata, C01 a nyelvgyök rosszindulatú daganata és így tovább2. Az esetek számát az N nevű változó tartalmazza, a háttérpopuláció lélekszámát3, tehát, hogy hány fő volt adott évben, adott megyében, adott nemben, adott életkorban – pedig a Population. (Ez tehát azonos lesz azokra a sorokra, amelyek csak a rák típusában térnek el, hiszen ezekre a háttérpopuláció lélekszáma természetesen ugyanaz.)\nEz a probléma a legtöbb szokásos elemzési feladatnál nem jelentkezik, itt sem fogunk rá részletes példát nézni, de röviden érdemes arról megemlékezni, hogy a hagyományos adatkeret (data frame) adatstuktúra nem szerencsés, ha nagyméretű adatbázisokat kell kezelnünk.\nAz első probléma kapásból az adatok beolvasásánál fog jelentkezni: a read.csv (és társai) egész egyszerűen lassúak. Pár százezer sorig ennek semmilyen érzékelhető hatása nincsen, mert még így is elég gyors a beolvasás, így a legtöbb feladatnál ez a probléma nem jelentkezik, de millió soros, több millió soros adatbázisoknál, ha a tábla mérete több gigabájt vagy több tíz gigabájt, akkor a beolvasás a méret növekedtével gyorsan lassul, míg végül teljesen reménytelenné válik. A data.table definiálja az fread függvényt mely ezzel szemben villámgyors, és még ilyen méretű adatok beolvasásánál is elfogadható sebességet produkál. (Az fread-nek ezen kívül van pár további előnye is az R beépített beolvasó függvényeihez képest, olyan, amik kis méretű adatbázisoknál is érdekesek lehetnek, például nagyon okosan detektálja az oszlopelválasztókat és az oszloptípusokat.) Hasonló a helyzet kiírásnál: a write.csv és társai nagyon nagy adatbázisoknál elfogadhatatlanul lassúak lesznek, de a data.table könyvtár fwrite függvénye ilyenkor is jól működik.\nA második probléma, hogy még ha valahogy be is olvastuk az adatbázist a memóriába, akkor is bajban leszünk az adattranszformációkkal: a data frame nincs túl jól optimalizálva ilyen szempontból, egy sor művelet nagyon lassú. Ismét csak: ennek kis, közepes és a legtöbb terület mércéje szerinti nagy adatbázisoknál nincs jelentősége, mert még így is gyors, de a nagyon nagy adatbázisoknál bajban leszünk data frame-et használva. A data table ezzel szemben nagyon jól optimalizált, képest többmagú processzoroknál bizonyos műveletek párhuzamos végrehajtására is, így az adattranszformációs műveleteknél4 (aggregáció, táblaegyesítések, de akár új változó létrehozása) sokkal jobb sebességet tud produkálni.\nA fentieket többféle benchmark vizsgálat is megerősíti.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#jobb-kiíratás",
    "href": "datatable.html#jobb-kiíratás",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.2 Jobb kiíratás",
    "text": "5.2 Jobb kiíratás\nA data frame kiíratásánál (tehát ha egyszerűen beírjuk, hogy RawDataDF, ami ekvivalens a print(RawDataDF) függvény meghívásával) az alapbeállítás az, hogy kiírja a konzolra az első jó sok sorát az adatbázisnak5. Ez nem túl praktikus: az 587. sor ismerete jellemzően nem sokat ad hozzá az első 586-hoz, cserében hosszasan kell görgetnünk a rengeteg sor miatt, hogy elérjünk a kiíratás tetejére, aminek viszont volna jelentősége, mert ott látjuk az oszlopok neveit. (Nem véletlenül gyakori, hogy sokan eleve a head(RawDataDF) típusú kéréssel íratják ki a data frame-eket!)\nA data table alapértelmezett kiíratása okosabb, mert csak az első néhány és az utolsó néhány sort6 írja ki:\n\nRawData\n\nKey: &lt;County, Sex, Age, Year&gt;\n                County    Sex   Age  Year ICDCode     N Population\n                &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n      1: Baranya megye  Férfi     0  2000     C00     0     9876.0\n      2: Baranya megye  Férfi     0  2000     C01     0     9876.0\n      3: Baranya megye  Férfi     0  2000     C02     0     9876.0\n      4: Baranya megye  Férfi     0  2000     C03     0     9876.0\n      5: Baranya megye  Férfi     0  2000     C04     0     9876.0\n     ---                                                          \n1313276:    Zala megye     Nő    85  2018     D06     0     4483.5\n1313277:    Zala megye     Nő    85  2018     D07     0     4483.5\n1313278:    Zala megye     Nő    85  2018     D09     0     4483.5\n1313279:    Zala megye     Nő    85  2018     D30     0     4483.5\n1313280:    Zala megye     Nő    85  2018     D33     0     4483.5\n\n\nTermészetesen láthatóak az oszlopfejlécek (változónevek) is, sőt, itt van még egy további apró fejlesztés: a data table kiírja az egyes oszlopok adattípusát is, standard rövidítéssel.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#kényelmesebb-sorindexelés-sor-szűrés-és--rendezés",
    "href": "datatable.html#kényelmesebb-sorindexelés-sor-szűrés-és--rendezés",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.3 Kényelmesebb sorindexelés (sor-szűrés és -rendezés)",
    "text": "5.3 Kényelmesebb sorindexelés (sor-szűrés és -rendezés)\nData frame indexeléséhez szögletes zárójelet kell írnunk a változó neve után, abba vesszőt tennünk, majd a vessző elé kerül az sor indexelése. Ezt tipikusan szűréshez használjuk. Például, ha ki akarjuk választani csak a 2010-es év adatait:\n\nhead(RawDataDF[RawDataDF$Year == 2010,])\n\n           County   Sex Age Year ICDCode N Population\n961 Baranya megye Férfi   0 2010     C00 0       9430\n962 Baranya megye Férfi   0 2010     C01 0       9430\n963 Baranya megye Férfi   0 2010     C02 0       9430\n964 Baranya megye Férfi   0 2010     C03 0       9430\n965 Baranya megye Férfi   0 2010     C04 0       9430\n966 Baranya megye Férfi   0 2010     C05 0       9430\n\n\nEz lényegében a „logikai vektorral indexelés” esete: a RawDataDF$Year == 2010 egy adatbázissal sorainak számával azonos hosszúságú logikai vektor lesz.\nHa ki akarjuk választani 2010 évben a 40 évnél idősebbek adatait, akkor a logikai ÉS operátort (&) kell használnunk; ez egyúttal azt is szemlélteti, hogy a feltételek természetesen nem csak egyenlőségek lehetnek:\n\nhead(RawDataDF[RawDataDF$Year == 2010 & RawDataDF$Age &gt;= 40,])\n\n             County   Sex Age Year ICDCode N Population\n15553 Baranya megye Férfi  40 2010     C00 0      13076\n15554 Baranya megye Férfi  40 2010     C01 0      13076\n15555 Baranya megye Férfi  40 2010     C02 0      13076\n15556 Baranya megye Férfi  40 2010     C03 0      13076\n15557 Baranya megye Férfi  40 2010     C04 0      13076\n15558 Baranya megye Férfi  40 2010     C05 0      13076\n\n\nA dolog hasonlóan folytatódik, ha további feltételek vannak. Például 2010 évben a 40 évnél idősebb budapesti vagy Pest megyei férfiak körében előforduló vastagbélrákos (BNO-kód: C18) esetek kiválasztása:\n\nhead(RawDataDF[RawDataDF$Year == 2010 &  RawDataDF$Age &gt;= 40 &\n                 RawDataDF$County %in% c(\"Budapest\",\n                                         \"Pest megye\") &\n                 RawDataDF$Sex == \"Férfi\" &\n                 RawDataDF$ICDCode == \"C18\",])\n\n         County   Sex Age Year ICDCode   N Population\n146899 Budapest Férfi  40 2010     C18   3    57445.5\n148723 Budapest Férfi  45 2010     C18  10    42410.0\n150547 Budapest Férfi  50 2010     C18  17    45329.0\n152371 Budapest Férfi  55 2010     C18  44    55633.5\n154195 Budapest Férfi  60 2010     C18  59    45170.0\n156019 Budapest Férfi  65 2010     C18 120    39588.0\n\n\nA dolog tökéletesen működik, ámde nem túl kényelmes: folyton be kell írni a RawDataDF$-t a feltételek közé. A kód hosszú, lassabb megírni, és az olvashatóság is romlik. Fontos hangsúlyozni, hogy ez nem hagyható el, és teljesen igaza is van az R-nek, hogy nem hagyható el: Year nevű változó nem létezik, tehát teljes joggal ad hibát, ha előle – vagy bármelyik másik elől – elhagyjuk a data frame nevét.\nMégis: a gyakorlatban az esetek 99,99%-ában, ha egy változó nevére hivatkozunk miközben egy adatkeret sorindexelését végezzük, akkor azt természetesen úgy értjük, hogy annak az adatkeretnek az adott nevű oszlopa (és nem egy külső változó). Éppen emiatt a data table megengedi ezt a szintaktikát: ha pusztán egy változó nevére hivatkozunk, akkor ő megnézi, hogy nincs-e olyan nevű oszlopa az indexelt adattáblának, és ha van, akkor úgy veszi, hogy arra szerettünk volna hivatkozni. Éppen ezért az alábbi kód data.frame-mel nem, de data.table-lel működik:\n\nRawData[Year == 2010 & Age &gt;= 40 &\n          County %in% c(\"Budapest\", \"Pest megye\") &\n          Sex == \"Férfi\" & ICDCode == \"C18\",]\n\nKey: &lt;County, Sex, Age, Year&gt;\n        County    Sex   Age  Year ICDCode     N Population\n        &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1:   Budapest  Férfi    40  2010     C18     3    57445.5\n 2:   Budapest  Férfi    45  2010     C18    10    42410.0\n 3:   Budapest  Férfi    50  2010     C18    17    45329.0\n 4:   Budapest  Férfi    55  2010     C18    44    55633.5\n 5:   Budapest  Férfi    60  2010     C18    59    45170.0\n 6:   Budapest  Férfi    65  2010     C18   120    39588.0\n 7:   Budapest  Férfi    70  2010     C18    80    27335.5\n 8:   Budapest  Férfi    75  2010     C18    75    22253.5\n 9:   Budapest  Férfi    80  2010     C18    72    15775.5\n10:   Budapest  Férfi    85  2010     C18    35    10922.0\n11: Pest megye  Férfi    40  2010     C18     8    48086.0\n12: Pest megye  Férfi    45  2010     C18     6    36113.5\n13: Pest megye  Férfi    50  2010     C18    14    37167.0\n14: Pest megye  Férfi    55  2010     C18    32    41154.0\n15: Pest megye  Férfi    60  2010     C18    43    32527.0\n16: Pest megye  Férfi    65  2010     C18    56    26071.0\n17: Pest megye  Férfi    70  2010     C18    62    16926.5\n18: Pest megye  Férfi    75  2010     C18    45    11964.5\n19: Pest megye  Férfi    80  2010     C18    23     7015.0\n20: Pest megye  Férfi    85  2010     C18    11     4250.5\n        County    Sex   Age  Year ICDCode     N Population\n\n\nA kapott kód világosabb, gyorsabban beírható és jobban olvasható!\nA data table azt is megengedi, hogy a vesszőt elhagyjuk (a data frame nem, ott hibát adna ha nem írnánk vesszőt!):\n\nRawData[Year == 2010 & Age &gt;= 40 &\n          County %in% c(\"Budapest\", \"Pest megye\") &\n          Sex == \"Férfi\" & ICDCode == \"C18\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n        County    Sex   Age  Year ICDCode     N Population\n        &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1:   Budapest  Férfi    40  2010     C18     3    57445.5\n 2:   Budapest  Férfi    45  2010     C18    10    42410.0\n 3:   Budapest  Férfi    50  2010     C18    17    45329.0\n 4:   Budapest  Férfi    55  2010     C18    44    55633.5\n 5:   Budapest  Férfi    60  2010     C18    59    45170.0\n 6:   Budapest  Férfi    65  2010     C18   120    39588.0\n 7:   Budapest  Férfi    70  2010     C18    80    27335.5\n 8:   Budapest  Férfi    75  2010     C18    75    22253.5\n 9:   Budapest  Férfi    80  2010     C18    72    15775.5\n10:   Budapest  Férfi    85  2010     C18    35    10922.0\n11: Pest megye  Férfi    40  2010     C18     8    48086.0\n12: Pest megye  Férfi    45  2010     C18     6    36113.5\n13: Pest megye  Férfi    50  2010     C18    14    37167.0\n14: Pest megye  Férfi    55  2010     C18    32    41154.0\n15: Pest megye  Férfi    60  2010     C18    43    32527.0\n16: Pest megye  Férfi    65  2010     C18    56    26071.0\n17: Pest megye  Férfi    70  2010     C18    62    16926.5\n18: Pest megye  Férfi    75  2010     C18    45    11964.5\n19: Pest megye  Férfi    80  2010     C18    23     7015.0\n20: Pest megye  Férfi    85  2010     C18    11     4250.5\n        County    Sex   Age  Year ICDCode     N Population\n\n\nFontos azonban, hogy ez csak ebben az esetben, tehát sorindexelésnél használható: ha nincs vessző, akkor automatikusan úgy veszi, hogy amit beírtunk, az sorindex (e megállapodás nélkül nem tudhatná, hogy mit akartunk indexelni).\nA tény, hogy nem kell hivatkozni az adatkeret nevére, nem csak szűrésnél igaz, hanem rendezésnél is. Ezt ugyanis az order függvény valósítja meg, ami elérhető volt a data frame-hez is, csak ott ilyen módon kellett használnunk:\n\nhead(RawDataDF[order(RawDataDF$N),])\n\n         County   Sex Age Year ICDCode N Population\n1 Baranya megye Férfi   0 2000     C00 0       9876\n2 Baranya megye Férfi   0 2000     C01 0       9876\n3 Baranya megye Férfi   0 2000     C02 0       9876\n4 Baranya megye Férfi   0 2000     C03 0       9876\n5 Baranya megye Férfi   0 2000     C04 0       9876\n6 Baranya megye Férfi   0 2000     C05 0       9876\n\n\nA data table azonban itt is megengedi7 a fenti – nagyon logikus – egyszerűsítést:\n\nRawData[order(N),]\n\n                County    Sex   Age  Year ICDCode     N Population\n                &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n      1: Baranya megye  Férfi     0  2000     C00     0     9876.0\n      2: Baranya megye  Férfi     0  2000     C01     0     9876.0\n      3: Baranya megye  Férfi     0  2000     C02     0     9876.0\n      4: Baranya megye  Férfi     0  2000     C03     0     9876.0\n      5: Baranya megye  Férfi     0  2000     C04     0     9876.0\n     ---                                                          \n1313276:      Budapest     Nő    60  2008     C50   307    64674.0\n1313277:      Budapest     Nő    55  2000     C50   308    67218.5\n1313278:      Budapest     Nő    55  2002     C50   308    69118.0\n1313279:      Budapest     Nő    70  2018     C44   331    56508.0\n1313280:      Budapest     Nő    55  2003     C50   350    69396.5\n\n\nTermészetesen a „szűrés” és „rendezés” csak felhasználói szempontból két külön művelet. Az R számára a kettő ugyanaz: sorindexelés, csak annyi eltéréssel, hogy az előbbi esetben logikai vektort kap, az utóbbiban pedig számvektort (hiszen az order egyszerűen megadja sorban minden elemre, hogy az adott elem hányadik a nagyság szerinti sorrendben).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#kibővített-oszlopindexelés-oszlop-kiválasztás-és-oszlop-létrehozás-műveletekkel",
    "href": "datatable.html#kibővített-oszlopindexelés-oszlop-kiválasztás-és-oszlop-létrehozás-műveletekkel",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.4 Kibővített oszlopindexelés: oszlop-kiválasztás és oszlop-létrehozás műveletekkel",
    "text": "5.4 Kibővített oszlopindexelés: oszlop-kiválasztás és oszlop-létrehozás műveletekkel\nHagyományos data frame esetén a vessző után jön az oszlopindexelés, ami egy dolgot jelenthet: oszlopok kiválasztását. Tehát, dönthetünk, hogy mely oszlopokat kérjük (és melyeket nem), de más lehetőségünk nincs. Oszlopok kiválasztását célszerű mindig névvel és nem számmal végeznünk (hogy a kód az adatbázis esetleges későbbi módosításaira robusztusabb legyen, ne romoljon el új oszlop beszúrásától vagy törlésétől, valamint, hogy önállóan is jobban olvasható legyen a kód). Ekkor lényegében egy sztring-vektort kell átadnunk. A példa kedvéért itt – az előzőekkel szemben – a 40-45 éves budapesti férfiak vastagbélrákos eseteire szorítsuk meg magunkat, viszont tartsuk meg az összes évet. Ez esetben logikus csak az évet – és persze az N-et és a Population-t – kiíratni, hiszen a többi konstans:\n\nhead(RawDataDF[RawDataDF$Age == 40 &\n                 RawDataDF$County == \"Budapest\" &\n                 RawDataDF$Sex == \"Férfi\" &\n                 RawDataDF$ICDCode == \"C18\",\n               c(\"Year\", \"N\", \"Population\")])\n\n       Year N Population\n145939 2000 8    51602.0\n146035 2001 4    47836.0\n146131 2002 4    45296.5\n146227 2003 4    43632.5\n146323 2004 4    43085.0\n146419 2005 5    43442.5\n\n\nEz a szintaktika a data.table-lel is működik8:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        c(\"Year\", \"N\", \"Population\")]\n\n     Year     N Population\n    &lt;num&gt; &lt;int&gt;      &lt;num&gt;\n 1:  2000     8    51602.0\n 2:  2001     4    47836.0\n 3:  2002     4    45296.5\n 4:  2003     4    43632.5\n 5:  2004     4    43085.0\n 6:  2005     5    43442.5\n 7:  2006     5    44511.5\n 8:  2007     6    46903.5\n 9:  2008     4    50505.5\n10:  2009     6    54015.0\n11:  2010     3    57445.5\n12:  2011     8    60721.0\n13:  2012     7    62471.5\n14:  2013     5    63746.5\n15:  2014     8    66250.5\n16:  2015    13    70511.5\n17:  2016    11    74622.0\n18:  2017     6    77902.0\n19:  2018    10    80555.0\n\n\nA data.table-nek van azonban egy saját, külön szintaktikája erre, és célszerű is azt megszokni és használni mindig, mert a későbbi funkciókat az teszi elérhetővé:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, N, Population)]\n\n     Year     N Population\n    &lt;num&gt; &lt;int&gt;      &lt;num&gt;\n 1:  2000     8    51602.0\n 2:  2001     4    47836.0\n 3:  2002     4    45296.5\n 4:  2003     4    43632.5\n 5:  2004     4    43085.0\n 6:  2005     5    43442.5\n 7:  2006     5    44511.5\n 8:  2007     6    46903.5\n 9:  2008     4    50505.5\n10:  2009     6    54015.0\n11:  2010     3    57445.5\n12:  2011     8    60721.0\n13:  2012     7    62471.5\n14:  2013     5    63746.5\n15:  2014     8    66250.5\n16:  2015    13    70511.5\n17:  2016    11    74622.0\n18:  2017     6    77902.0\n19:  2018    10    80555.0\n\n\nMegjegyzendő, hogy a . egyszerűen egy rövidítés, amit a data.table csomag bevezet arra, hogy list, magyarán itt az történik, hogy egy listát kell átadnunk9, benne az – idézőjelek nélküli – oszlopnevekkel. A listás megoldás előnye, hogy valójában nem kötelező explicite kiírni, hogy . majd felsorolni a változóneveket zárójelben, bármilyen függvényt is használhatunk a vessző után ami listát ad eredményül. Később látunk majd erre példát.\nAz is érthető a listás megoldás fényében, hogy data table-lel átnevezhetünk változót úgymond „menet közben” (data frame-mel már ezt sem lehetett!):\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, Esetszam = N, Lelekszam = Population)]\n\n     Year Esetszam Lelekszam\n    &lt;num&gt;    &lt;int&gt;     &lt;num&gt;\n 1:  2000        8   51602.0\n 2:  2001        4   47836.0\n 3:  2002        4   45296.5\n 4:  2003        4   43632.5\n 5:  2004        4   43085.0\n 6:  2005        5   43442.5\n 7:  2006        5   44511.5\n 8:  2007        6   46903.5\n 9:  2008        4   50505.5\n10:  2009        6   54015.0\n11:  2010        3   57445.5\n12:  2011        8   60721.0\n13:  2012        7   62471.5\n14:  2013        5   63746.5\n15:  2014        8   66250.5\n16:  2015       13   70511.5\n17:  2016       11   74622.0\n18:  2017        6   77902.0\n19:  2018       10   80555.0\n\n\nEz már utat mutat a következő, igazi újdonsághoz.\nElőtte még említsük meg, hogy a data table egyik jellegzetessége, hogy a RawData[, .(Year)] típusú hívások mindig data table-t adnak vissza10. Ha egyetlen változót választunk ki, de azt vektorként szeretnénk visszakapni (ez a kérdés nyilván csak egyetlen változó kiválasztásakor merül fel), akkor használjuk a RawData$Year vagy a RawData[[\"Year\"]] formát11.\nEz eddig nem nagy változás, még csak azt sem igazán lehet mondani, hogy az előzőhöz hasonló kényelmi továbbfejlesztés, hiszen ez a szintaktika nem sokkal tér el a korábbitól. Az igazán érdekes rész azonban most jön, a data.table ugyanis lehetővé tesz valamit, ami a data.frame-nél fel sem merült: nem csak passzívan kiválaszthatunk oszlopokat, hanem műveleteket is végezhetünk velük, így új oszlopokat hozva létre! Lényegében „on the fly”, azaz menet közben végezhetünk műveleteket és hozhatunk létre új oszlopokat, anélkül, hogy azokat fizikailag le kellene tárolnunk az adatbázisba. A data table vessző utáni pozíciójában tehát\nPéldául a rákos megbetegedéseknél fontos az incidencia, tehát a lélekszámhoz viszonyított előfordulás. (Értelemszerűen nem mindegy, hogy 10 vagy 10 ezer ember közül került ki 1 rákos adott évben.) Ezt tipikusan 100 ezer lakosra vonatkoztatva szokták megadni. Nézzük meg a következő data table-t használó megoldást:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, N, Population, Inc = N / Population * 1e5)]\n\n     Year     N Population       Inc\n    &lt;num&gt; &lt;int&gt;      &lt;num&gt;     &lt;num&gt;\n 1:  2000     8    51602.0 15.503275\n 2:  2001     4    47836.0  8.361903\n 3:  2002     4    45296.5  8.830704\n 4:  2003     4    43632.5  9.167478\n 5:  2004     4    43085.0  9.283974\n 6:  2005     5    43442.5 11.509467\n 7:  2006     5    44511.5 11.233052\n 8:  2007     6    46903.5 12.792222\n 9:  2008     4    50505.5  7.919930\n10:  2009     6    54015.0 11.108026\n11:  2010     3    57445.5  5.222341\n12:  2011     8    60721.0 13.175014\n13:  2012     7    62471.5 11.205110\n14:  2013     5    63746.5  7.843568\n15:  2014     8    66250.5 12.075381\n16:  2015    13    70511.5 18.436709\n17:  2016    11    74622.0 14.740961\n18:  2017     6    77902.0  7.701985\n19:  2018    10    80555.0 12.413879\n\n\nAzaz az Inc oszlopot létrehoztuk a nélkül, hogy előzetesen azt le kellett volna tárolnunk magába az adatbázisba! Menet közben számoltuk ki, és még nevet is adtunk neki. Az oszlopok tehát itt, a vessző utáni pozícióban úgy viselkednek egy data table-nél mintha szokásos változók lennének!\nEbből is adódik, hogy a lehetőségeink még ennél is bővebbek: nem csak egyszerű aritmetikai műveleteket végezhetünk egy oszloppal (vagy épp több oszloppal! – mint arra ez előbbi kód is példát mutat), hanem bármilyen R függvényt rájuk ereszthetünk! Tekintsünk példának a következő kódot, mely megadja, hogy a 40-45 éves budapesti férfiak körében összesen hány vastagbélrákos eset volt az adatbázis által lefedett 19 év alatt:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(N = sum(N))]\n\n       N\n   &lt;int&gt;\n1:   121\n\n\nAz N oszlop egy vektor, tehát azon túl, hogy oszthatjuk – elemenként – egy másik vektorral, mint ahogy az előbbi esetben tettük, nyugodtan összegezhetjük is példának okáért. Ebből mellesleg az is látszik, hogy még az sem jelent problémát, ha a művelet által visszaadott eredménynek a hossza is eltér a bemenő változóétól! Hiszen a sum(N) 1 hosszú, míg a Year 19. (Az azonban fontos, hogy itt már a Year nem szerepel a kiválasztott oszlopok között: megtarthattuk volna a Year-t is, de mivel az 19 hosszú, így a mellette lévő oszlopban ugyanaz az összeg 19-szer meg lett volna ismételve.)\nA fenti példákban egyszerre szűrtünk sorokat és számoltunk oszlopokat. (Ez természetesen nem kötelező, lehet csak az egyiket csinálni a másik nélkül.) Egyetlen példa a data.table optimalizálására: ilyenkor nem azt csinálja, hogy leszűri az egész adatbázist, és aztán végzi az oszlopműveleteket, hanem először megnézi, hogy mely oszlopokra van egyáltalán szükség – például csak a Year-re, N-re és Population-re – és ilyenkor csak azokat szűri le, így kerülve el, hogy olyan oszlopok szűrését is el kelljen végeznie, amik később nem is jelennek meg az eredményben. Ez azért lehetséges, mert a data.table „egyben látja” az egész feladatot, és így tud ilyen optimalizálásokat tenni.\nVisszatérve, a dolog még jobban kombinálható: legyen a példa kedvéért a feladatunk az, hogy számoljuk ki az egész 19 éves periódusra az incidenciát. (Egy pillanatra érdemes itt megállni, és végiggondolni, hogy mi egyáltalán az ehhez szükséges művelet!) Íme a megvalósítás data.table használatával:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]\n\n       Inc\n     &lt;num&gt;\n1: 11.1515\n\n\nAmint láthatjuk, tetszőleges komplexitású műveletet, számítást elvégezhetünk a vessző után! És ezt szó szerint kell érteni: bármilyen R függvényt használhatunk az oszlopindexelés pozíciójában, a vessző után, bármilyen műveletet vagy számítást végezhetünk (tehát még csak olyan megkötés sincs, hogy csak bizonyos függvényeket, műveleteket tesz csak elérhetővé a data.table). Íme egy példa; lognormális eloszlást illesztünk az esetszámok különböző években mért értékeiből kapott eloszlásra:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(fitdistrplus::fitdist(N, \"lnorm\")$estimate[\"meanlog\"])]\n\n         V1\n      &lt;num&gt;\n1: 1.772807\n\n\nSzépen látszik itt is, hogy nyugodtan használhatjuk az N-et csak így, minden további nélkül – ugyanúgy viselkedik, mint egy szokásos változó, ugyanúgy használhatjuk egy számítás során.\nRáadásul, ha visszaemlékszünk, akkor szerepelt, hogy a vessző utáni pozícióban egy listának kell szerepelnie – de ezt előállíthatja egy függvény is! Például a fitdistrplus::fitdist eredményének estimate nevű komponense egy vektor. De ha ez as.list-tel átalakítjuk, akkor egy listát kapunk, így közvetlenül átadható a vessző utáni pozícióban (természetesen ilyenkor . nem kell, hiszen az as.list eleve egy listát ad vissza!):\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        as.list(fitdistrplus::fitdist(N, \"lnorm\")$estimate)]\n\n    meanlog     sdlog\n      &lt;num&gt;     &lt;num&gt;\n1: 1.772807 0.3902478\n\n\nEz tehát már messze-messze nem csak egyszerűen oszlopkiválasztás, amire itt módunk van, ha data.table-t használunk.\nEgyetlen megjegyzés a végére: mi van akkor, ha kíváncsiak vagyunk arra, hogy hány sor van egy adattáblában (esetleg szűkítés után)? A RawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" & ICDCode == \"C18\", length(N)] kézenfekvő megoldás, de nem túl elegáns (miért pont az N hosszát néztük meg? bármi más is ugyanezt az eredményt adná!). Erre a célra a data.table bevezet egy speciális szimbólumot, a .N-et, ami egyszerűen visszaadja12 a sorok számát:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\", .N]\n\n[1] 19",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#csoportosítás-aggregáció",
    "href": "datatable.html#csoportosítás-aggregáció",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.5 Csoportosítás (aggregáció)",
    "text": "5.5 Csoportosítás (aggregáció)\nA data.table második, rendkívül erőteljes bővítése a hagyományos data frame funkcionalitásához képest a csoportosítás (aggregáció) lehetősége. A data.table bevezet egy harmadik pozíciót a szögletes zárójelen belül: megtehetjük, hogy két vesszőt teszünk ki a szögletes zárójelen belül, ez esetben az első vessző előtt van a sorindexelés (ahogy eddig is), az első és a második vessző között az oszlopkiválasztás és -számítás (ahogy eddig is), viszont a második vessző után megadhatunk egy listát egy vagy több változóból. (A . ugyanúgy használható a list helyett. Megadhatunk sztring-vektort is, benne a változók neveivel; ez különösen jól jön akkor, ha gépi úton állítjuk elő, hogy mik ezek a változók.) Mi fog ilyenkor történni? A data.table elsőként végrehajtja a sorok szűrését, ha kértünk ilyet, ezután pedig az új, harmadik pozícióban megadott változó vagy változók szerint csoportokat képez. Mit jelent az, hogy „csoport”? Azok a sorai a táblának, amelyekben a csoportosító változó egy adott értéket vesz fel: ahány lehetséges értéke van a csoportosító változónak a táblában, annyi csoport képződik, úgy, hogy csoporton belül a csoportosító változó homogén lesz. Ezt követően a data.table végrehajtja a megadott oszlopkiválasztásokat és/vagy oszlopműveleteket csoportonként külön-külön, végül pedig a kapott eredményeket újra összerakja egy táblába, úgy, hogy mindegyik csoport eredménye mellé beteszi oszlopként azt, hogy ott mi volt a csoportosító változó értéke. Az egyes csoportok abban a sorrendben fognak szerepelni az eredményben, ahogy egymás után jöttek a kiinduló táblában.\nA jobb megértés kedvéért nézzünk egy gyakorlati példát! Kíváncsiak vagyunk az egész időintervallumra vonatkozó incidenciára, de az összes rák-típus esetén külön-külön megadva. Mit tudunk tenni? Fent láttuk a kódot, mely egy adott típusra ezt kiszámolja. Az remélhetőleg senkinek nem jut az eszébe, hogy kézzel lefuttassa először C00-val, aztán C01-gyel, aztán C02-vel… Működőképesebb megoldás ennek valamilyen R paranccsal történő automatizálása. Rosszabb esetben a for jut az eszünkbe, jobb esetben az apply család valamely tagja. (A for-ciklus rosszabb eset, mert az R-ben a legtöbb esetben illendő kerülni, és jelen esetben tényleg meg is oldható a probléma megfelelő apply használatával, így ez is a célszerű választás.) Ha azonban a data.table-t használjuk, akkor még csak erre sincs szükség!\nNézzük ugyanis meg a következő hívást:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(ICDCode)]\n\n    ICDCode         Inc\n     &lt;char&gt;       &lt;num&gt;\n 1:     C00  0.36864474\n 2:     C01  2.21186843\n 3:     C02  2.58051316\n 4:     C03  1.01377303\n 5:     C04  2.48835198\n 6:     C05  0.73728948\n 7:     C06  0.55296711\n 8:     C07  0.92161184\n 9:     C08  0.73728948\n10:     C09  1.65890132\n11:     C10  3.13348027\n12:     C11  1.19809540\n13:     C12  0.46080592\n14:     C13  4.42373685\n15:     C14  0.82945066\n16:     C15  4.14725330\n17:     C16  6.72776646\n18:     C17  1.75106250\n19:     C18 11.15150331\n20:     C19  2.58051316\n21:     C20  7.09641120\n22:     C21  0.55296711\n23:     C22  3.87076974\n24:     C23  1.01377303\n25:     C24  1.47457895\n26:     C25  7.37289475\n27:     C26  0.46080592\n28:     C30  0.64512829\n29:     C31  1.10593421\n30:     C32  7.46505593\n31:     C33  0.09216118\n32:     C34 30.78183558\n33:     C37  0.46080592\n34:     C38  1.10593421\n35:     C39  0.36864474\n36:     C40  1.01377303\n37:     C41  2.94915790\n38:     C43 17.41846385\n39:     C44 43.13143429\n40:     C45  0.64512829\n41:     C46  0.46080592\n42:     C47  0.00000000\n43:     C48  2.39619079\n44:     C49 10.78285857\n45:     C50  2.76483553\n46:     C51  0.00000000\n47:     C52  0.00000000\n48:     C53  0.00000000\n49:     C54  0.00000000\n50:     C55  0.00000000\n51:     C56  0.00000000\n52:     C57  0.00000000\n53:     C58  0.00000000\n54:     C60  0.92161184\n55:     C61  2.94915790\n56:     C62 22.11868425\n57:     C63  0.64512829\n58:     C64 12.25743752\n59:     C65  0.27648355\n60:     C66  0.00000000\n61:     C67  8.38666778\n62:     C68  0.18432237\n63:     C69  1.10593421\n64:     C70  0.55296711\n65:     C71  8.75531252\n66:     C72  1.10593421\n67:     C73  5.06886514\n68:     C74  0.73728948\n69:     C75  0.27648355\n70:     C76  2.67267435\n71:     C80  2.39619079\n72:     C81  3.40996382\n73:     C82  2.58051316\n74:     C83  3.96293093\n75:     C84  0.92161184\n76:     C85  4.42373685\n77:     C88  0.00000000\n78:     C90  2.21186843\n79:     C91  3.31780264\n80:     C92  4.51589803\n81:     C93  0.00000000\n82:     C94  0.18432237\n83:     C95  0.09216118\n84:     C96  1.56674013\n85:     C97  0.00000000\n86:     D00  0.46080592\n87:     D01  0.18432237\n88:     D02  0.09216118\n89:     D03  4.60805922\n90:     D04  1.75106250\n91:     D05  0.00000000\n92:     D06  0.00000000\n93:     D07  0.36864474\n94:     D09  0.27648355\n95:     D30  1.38241777\n96:     D33  6.26696054\n    ICDCode         Inc\n\n\nMi történt itt? Először is, a sor-szűrések közül kivettük a konkrét rák-típust – ez értelemszerű, hiszen az összes ráktípusra vonatkozó adatot szeretnénk kapni, épp ez volt a feladat, tehát ebben nyilván nem szűrhetjük le előzetesen az adatbázist. Másodszor, bekerült a harmadik pozíciója, csoportosító változóként a rák típusa. Mit jelent ez? Azt, hogy a szűrés után a data.table a leszűrt adatbázisból rák-típus szerint csoportokat képez, tehát szétszedi az adatbázist kis táblákra úgy, hogy mindegyikben egy adott rák-típus adatai legyenek, mindegyikre elvégzi a második pozícióban, az oszlopindexelésnél megadott műveleteket (jelen esetben: kiszámítja az incidenciákat), majd ezeket az eredményeket, ami itt most egyetlen sor lesz, újra összerakja egy nagy táblába, jelezve, hogy az adott eredmény melyik kódhoz tartozik.\nNagyon szájbarágós, de talán egyszer érdemes a dolgot megnézni lépésről-lépésre. A data.table elsőként leszűri a táblát a sorindex szerint:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n        County    Sex   Age  Year ICDCode     N Population\n        &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n   1: Budapest  Férfi    40  2000     C00     1      51602\n   2: Budapest  Férfi    40  2000     C01     6      51602\n   3: Budapest  Férfi    40  2000     C02     2      51602\n   4: Budapest  Férfi    40  2000     C03     1      51602\n   5: Budapest  Férfi    40  2000     C04     2      51602\n  ---                                                     \n1820: Budapest  Férfi    40  2018     D06     0      80555\n1821: Budapest  Férfi    40  2018     D07     0      80555\n1822: Budapest  Férfi    40  2018     D09     2      80555\n1823: Budapest  Férfi    40  2018     D30     0      80555\n1824: Budapest  Férfi    40  2018     D33     4      80555\n\n\nEzt követően megnézi, hogy a csoportosító változó milyen értékeket vesz fel:\n\nunique(RawData[Age == 40 & County == \"Budapest\" &\n                 Sex == \"Férfi\"]$ICDCode)\n\n [1] \"C00\" \"C01\" \"C02\" \"C03\" \"C04\" \"C05\" \"C06\" \"C07\" \"C08\" \"C09\" \"C10\" \"C11\"\n[13] \"C12\" \"C13\" \"C14\" \"C15\" \"C16\" \"C17\" \"C18\" \"C19\" \"C20\" \"C21\" \"C22\" \"C23\"\n[25] \"C24\" \"C25\" \"C26\" \"C30\" \"C31\" \"C32\" \"C33\" \"C34\" \"C37\" \"C38\" \"C39\" \"C40\"\n[37] \"C41\" \"C43\" \"C44\" \"C45\" \"C46\" \"C47\" \"C48\" \"C49\" \"C50\" \"C51\" \"C52\" \"C53\"\n[49] \"C54\" \"C55\" \"C56\" \"C57\" \"C58\" \"C60\" \"C61\" \"C62\" \"C63\" \"C64\" \"C65\" \"C66\"\n[61] \"C67\" \"C68\" \"C69\" \"C70\" \"C71\" \"C72\" \"C73\" \"C74\" \"C75\" \"C76\" \"C80\" \"C81\"\n[73] \"C82\" \"C83\" \"C84\" \"C85\" \"C88\" \"C90\" \"C91\" \"C92\" \"C93\" \"C94\" \"C95\" \"C96\"\n[85] \"C97\" \"D00\" \"D01\" \"D02\" \"D03\" \"D04\" \"D05\" \"D06\" \"D07\" \"D09\" \"D30\" \"D33\"\n\n\nMajd ezek mindegyikére leszűkíti a (szűrt) táblát, lényegében kis táblákat készítve. Így néz ki a C00-hoz tartozó:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C00\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n      County    Sex   Age  Year ICDCode     N Population\n      &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1: Budapest  Férfi    40  2000     C00     1    51602.0\n 2: Budapest  Férfi    40  2001     C00     1    47836.0\n 3: Budapest  Férfi    40  2002     C00     0    45296.5\n 4: Budapest  Férfi    40  2003     C00     0    43632.5\n 5: Budapest  Férfi    40  2004     C00     0    43085.0\n 6: Budapest  Férfi    40  2005     C00     0    43442.5\n 7: Budapest  Férfi    40  2006     C00     0    44511.5\n 8: Budapest  Férfi    40  2007     C00     0    46903.5\n 9: Budapest  Férfi    40  2008     C00     0    50505.5\n10: Budapest  Férfi    40  2009     C00     0    54015.0\n11: Budapest  Férfi    40  2010     C00     0    57445.5\n12: Budapest  Férfi    40  2011     C00     1    60721.0\n13: Budapest  Férfi    40  2012     C00     1    62471.5\n14: Budapest  Férfi    40  2013     C00     0    63746.5\n15: Budapest  Férfi    40  2014     C00     0    66250.5\n16: Budapest  Férfi    40  2015     C00     0    70511.5\n17: Budapest  Férfi    40  2016     C00     0    74622.0\n18: Budapest  Férfi    40  2017     C00     0    77902.0\n19: Budapest  Férfi    40  2018     C00     0    80555.0\n\n\nÍgy a C01-hez:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C01\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n      County    Sex   Age  Year ICDCode     N Population\n      &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1: Budapest  Férfi    40  2000     C01     6    51602.0\n 2: Budapest  Férfi    40  2001     C01     1    47836.0\n 3: Budapest  Férfi    40  2002     C01     0    45296.5\n 4: Budapest  Férfi    40  2003     C01     3    43632.5\n 5: Budapest  Férfi    40  2004     C01     2    43085.0\n 6: Budapest  Férfi    40  2005     C01     0    43442.5\n 7: Budapest  Férfi    40  2006     C01     3    44511.5\n 8: Budapest  Férfi    40  2007     C01     2    46903.5\n 9: Budapest  Férfi    40  2008     C01     0    50505.5\n10: Budapest  Férfi    40  2009     C01     2    54015.0\n11: Budapest  Férfi    40  2010     C01     0    57445.5\n12: Budapest  Férfi    40  2011     C01     3    60721.0\n13: Budapest  Férfi    40  2012     C01     1    62471.5\n14: Budapest  Férfi    40  2013     C01     1    63746.5\n15: Budapest  Férfi    40  2014     C01     0    66250.5\n16: Budapest  Férfi    40  2015     C01     0    70511.5\n17: Budapest  Férfi    40  2016     C01     0    74622.0\n18: Budapest  Férfi    40  2017     C01     0    77902.0\n19: Budapest  Férfi    40  2018     C01     0    80555.0\n\n\nÉs így tovább.\nEzt követően minden kis táblára elvégzi az oszlopindexelésnél kijelölt műveletet. Így fog kinézni az eredmény a C00-s kis táblára:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C00\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]\n\n         Inc\n       &lt;num&gt;\n1: 0.3686447\n\n\nÍgy a C01-es kis táblára:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C01\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]\n\n        Inc\n      &lt;num&gt;\n1: 2.211868\n\n\nMajd ezeket a kis táblákat egymás alá rendezi, abban a sorrendben, ahogy az eredeti táblában előfordultak a csoportosító változó értékei, és úgy, hogy mindegyikhez melléírja, hogy az adottnál mi volt a csoportosító változó értéke, tehát jelen esetben, hogy melyik ráktípushoz tartozik.\nÍgy kaptuk a fent látható táblát (menjünk vissza és ellenőrizzük)…!\nNézzünk meg – most már nagyon részletes levezetés nélkül – még egy példát csoportosításra. Kíváncsiak vagyunk egy adott ráktípus korspecifikus incidenciájára, tehát, hogy mennyi az incidencia adott életkorban. Ha mindezt rögzített évre, nemre és megyére kérdezzük, akkor célt érhetünk így:\n\nRawData[Year == 2010 & County == \"Budapest\" &\n          Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Age, Inc = N / Population * 1e5)]\n\n      Age        Inc\n    &lt;num&gt;      &lt;num&gt;\n 1:     0   0.000000\n 2:     5   0.000000\n 3:    10   0.000000\n 4:    15   0.000000\n 5:    20   1.960054\n 6:    25   3.072716\n 7:    30   2.321088\n 8:    35  11.088472\n 9:    40   5.222341\n10:    45  23.579344\n11:    50  37.503585\n12:    55  79.089038\n13:    60 130.617667\n14:    65 303.122158\n15:    70 292.659728\n16:    75 337.025636\n17:    80 456.403917\n18:    85 320.454129\n\n\nA dolog azonban nagyon nem szerencsés: kizárólag azért fog működni, mert a leszűkítés után egy adott életkorhoz már csak egyetlen sor tartozik. De ha ez nem így lenne, például kitörlünk valamit a feltételek közül, akkor teljesen rossz eredményt fog adni, hiszen ilyenkor ugyanaz az életkor többször fog megjelenni az eredményben, míg nekünk össze kellene adnunk az adott életkorhoz tartozó különböző megfigyeléseket.\nA megoldás a csoportosítás az életkor szerint, és az összeadás adott életkoron belül:\n\nRawData[Year == 2010 & County == \"Budapest\" &\n          Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5), .(Age)]\n\n      Age        Inc\n    &lt;num&gt;      &lt;num&gt;\n 1:     0   0.000000\n 2:     5   0.000000\n 3:    10   0.000000\n 4:    15   0.000000\n 5:    20   1.960054\n 6:    25   3.072716\n 7:    30   2.321088\n 8:    35  11.088472\n 9:    40   5.222341\n10:    45  23.579344\n11:    50  37.503585\n12:    55  79.089038\n13:    60 130.617667\n14:    65 303.122158\n15:    70 292.659728\n16:    75 337.025636\n17:    80 456.403917\n18:    85 320.454129\n\n\nEz immár működik másféle szűréssel is, például ha Budapest helyett az egész országra vagyunk kíváncsiak:\n\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5), .(Age)]\n\n      Age         Inc\n    &lt;num&gt;       &lt;num&gt;\n 1:     0   0.4013437\n 2:     5   0.0000000\n 3:    10   0.3909763\n 4:    15   0.3278087\n 5:    20   1.2121488\n 6:    25   2.2652654\n 7:    30   3.2732344\n 8:    35   7.1454000\n 9:    40  11.2810011\n10:    45  21.7613797\n11:    50  46.2794518\n12:    55  94.8719665\n13:    60 130.8683356\n14:    65 246.5976935\n15:    70 293.1432072\n16:    75 367.2073711\n17:    80 347.1158754\n18:    85 323.4103513\n\n\nÉrdemes végiggondolni (ez általában is hasznos): ilyenkor az életkor szerinti kis táblákban 20 sor lesz – az egyes megyékkel – és ezek fölött fogunk összegezni.\nMegjegyzendő, hogy a csoportosító változónak nevet is adhatunk:\n\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(Eletkor = Age)]\n\n    Eletkor         Inc\n      &lt;num&gt;       &lt;num&gt;\n 1:       0   0.4013437\n 2:       5   0.0000000\n 3:      10   0.3909763\n 4:      15   0.3278087\n 5:      20   1.2121488\n 6:      25   2.2652654\n 7:      30   3.2732344\n 8:      35   7.1454000\n 9:      40  11.2810011\n10:      45  21.7613797\n11:      50  46.2794518\n12:      55  94.8719665\n13:      60 130.8683356\n14:      65 246.5976935\n15:      70 293.1432072\n16:      75 367.2073711\n17:      80 347.1158754\n18:      85 323.4103513\n\n\nAmi azonban sokkal izgalmasabb, hogy műveletet is végezhetünk! Itt is igaz, hogy nem kell a változót külön letárolni, hanem menet közben kiszámolhatjuk, majd építhetünk is rá rögtön (jelen esetben egy csoportosítást). Például, ha ki akarjuk számolni az incidenciát külön a 70 év alattiak és felettiek körében:\n\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(Idos = Age &gt; 70)]\n\n     Idos       Inc\n   &lt;lgcl&gt;     &lt;num&gt;\n1:  FALSE  43.83737\n2:   TRUE 352.54419",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#indexelések-láncolása-egymás-után",
    "href": "datatable.html#indexelések-láncolása-egymás-után",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.6 Indexelések láncolása egymás után",
    "text": "5.6 Indexelések láncolása egymás után\nA data.table következő újítása, hogy megengedi egy már indexelt tábla (RawData[...]) újabb indexelését. Tehát használhatjuk a RawData[...][...] alakot, ahol a második indexelés pontosan ugyanúgy fog viselkedni, mint az első (ugyanúgy használhatunk sorindexelést, szűrést és rendezést, oszlopkiválasztást és -transzformációt, csoportosítást), de úgy, hogy az az első, már indexelt táblára vonatkozik! Lényegében mintha elmentettük volna a RawData[...]-t egy változóba, és utána azt a változót indexelnénk szokásos módon – csak itt nem kell semmit külön elmenteni. Az, hogy a második indexelés már az első indexelésben átalakított táblára vonatkozik, egy kritikusan fontos előny, amint az rögtön világossá is fog válni.\nHa pontosak akarunk lenni, akkor ezt az egymás utáni többszöri indexelést igazából a hagyományos data frame is megengedi, tehát például a RawDataDF[101:200,][5:15,] egy teljesen szabályos hívás (és természetesen egyenértékű lesz azzal, hogy RawDataDF[105:115,]). A probléma az, hogy a használhatósága nagyon korlátozott, mert a második indexben, ha változóra hivatkozunk, az az eredeti adatkeret változója tud csak lenni, nem az első indexelésben már áttranszformálté! (Értelemszerűen, hiszen az nincs is elmentve, nincs is semmilyen külön neve, ahogy hivatkozhatnánk rá.) Ha csak a legegyszerűbb transzformációt, a sorok szűrését vesszük: a RawDataDF[RawDataDF$Sex == \"Férfi\",][RawDataDF$Year == 2010,] nem fog működni, ez onnan is kapásból látszik, hogy a RawDataDF$Year == 2010 ugyanolyan hosszú, mint a a RawDataDF, viszont a RawDataDF[RawDataDF$Sex == \"Férfi\",] már rövidebb, tehát ez így biztosan nem lehet jó, mert az adattáblát hosszabb vektorral próbáljuk indexelni, mint ahány sora van. Data frame használatával erre a problémára nincs megoldás, hiszen a RawDataDF[RawDataDF$Sex == \"Férfi\",] táblázat Year változójára nem tudunk sehogy sem hivatkozni a második indexelésben, hiszen az nincs elmentve, nincs is külön neve, amivel hivatkozhatnánk.\nA data table esetében azonban, kihasználva, hogy a változóra hivatkozhatunk csak a nevével, a táblázat neve nélkül, erre nagyon egyszerű a megoldás: annyi a feladat, hogy a második indexben szereplő Year alatt a data.table azt értse, hogy az első indexelés után kapott táblázat Year nevű változója (ne azt, hogy az eredetié). És így is van megírva a data.table, ezért szerepelt korábban az a megfogalmazás, hogy a második index az első indexeléssel már transzformált táblára vonatkozik. Így aztán a következő hívás tökéletesen működik data table-lel:\n\nRawData[Sex == \"Férfi\"][Year == 2010]\n\nKey: &lt;County, Sex, Age, Year&gt;\n              County    Sex   Age  Year ICDCode     N Population\n              &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n    1: Baranya megye  Férfi     0  2010     C00     0     9430.0\n    2: Baranya megye  Férfi     0  2010     C01     0     9430.0\n    3: Baranya megye  Férfi     0  2010     C02     0     9430.0\n    4: Baranya megye  Férfi     0  2010     C03     0     9430.0\n    5: Baranya megye  Férfi     0  2010     C04     0     9430.0\n   ---                                                          \n34556:    Zala megye  Férfi    85  2010     D06     0     1447.5\n34557:    Zala megye  Férfi    85  2010     D07     0     1447.5\n34558:    Zala megye  Férfi    85  2010     D09     0     1447.5\n34559:    Zala megye  Férfi    85  2010     D30     0     1447.5\n34560:    Zala megye  Férfi    85  2010     D33     4     1447.5\n\n\nEz még nem a legátütőbb példa – bár sokszor az ilyenek is nagyon jól jönnek – hiszen használhattunk volna egyszerűen & jelet és egyetlen indexelést. A dolog igazi erejét az adja, hogy – ismét csak abból fakadóan, hogy a második index már az elsőnek indexelt táblát látja, neki nem is számít, hogy az nem egy lementett tábla, hanem egy már átalakított – módunk van menet közben létrehozott változókra is hivatkozni! Például miután kiszámoltuk rák-típusonként az incidenciát, szeretnénk a táblázatot az incidenciák szerint növekvő sorba rakni. Íme a megoldás:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(ICDCode)][order(Inc)]\n\n    ICDCode         Inc\n     &lt;char&gt;       &lt;num&gt;\n 1:     C47  0.00000000\n 2:     C51  0.00000000\n 3:     C52  0.00000000\n 4:     C53  0.00000000\n 5:     C54  0.00000000\n 6:     C55  0.00000000\n 7:     C56  0.00000000\n 8:     C57  0.00000000\n 9:     C58  0.00000000\n10:     C66  0.00000000\n11:     C88  0.00000000\n12:     C93  0.00000000\n13:     C97  0.00000000\n14:     D05  0.00000000\n15:     D06  0.00000000\n16:     C33  0.09216118\n17:     C95  0.09216118\n18:     D02  0.09216118\n19:     C68  0.18432237\n20:     C94  0.18432237\n21:     D01  0.18432237\n22:     C65  0.27648355\n23:     C75  0.27648355\n24:     D09  0.27648355\n25:     C00  0.36864474\n26:     C39  0.36864474\n27:     D07  0.36864474\n28:     C12  0.46080592\n29:     C26  0.46080592\n30:     C37  0.46080592\n31:     C46  0.46080592\n32:     D00  0.46080592\n33:     C06  0.55296711\n34:     C21  0.55296711\n35:     C70  0.55296711\n36:     C30  0.64512829\n37:     C45  0.64512829\n38:     C63  0.64512829\n39:     C05  0.73728948\n40:     C08  0.73728948\n41:     C74  0.73728948\n42:     C14  0.82945066\n43:     C07  0.92161184\n44:     C60  0.92161184\n45:     C84  0.92161184\n46:     C03  1.01377303\n47:     C23  1.01377303\n48:     C40  1.01377303\n49:     C31  1.10593421\n50:     C38  1.10593421\n51:     C69  1.10593421\n52:     C72  1.10593421\n53:     C11  1.19809540\n54:     D30  1.38241777\n55:     C24  1.47457895\n56:     C96  1.56674013\n57:     C09  1.65890132\n58:     C17  1.75106250\n59:     D04  1.75106250\n60:     C01  2.21186843\n61:     C90  2.21186843\n62:     C48  2.39619079\n63:     C80  2.39619079\n64:     C04  2.48835198\n65:     C02  2.58051316\n66:     C19  2.58051316\n67:     C82  2.58051316\n68:     C76  2.67267435\n69:     C50  2.76483553\n70:     C41  2.94915790\n71:     C61  2.94915790\n72:     C10  3.13348027\n73:     C91  3.31780264\n74:     C81  3.40996382\n75:     C22  3.87076974\n76:     C83  3.96293093\n77:     C15  4.14725330\n78:     C13  4.42373685\n79:     C85  4.42373685\n80:     C92  4.51589803\n81:     D03  4.60805922\n82:     C73  5.06886514\n83:     D33  6.26696054\n84:     C16  6.72776646\n85:     C20  7.09641120\n86:     C25  7.37289475\n87:     C32  7.46505593\n88:     C67  8.38666778\n89:     C71  8.75531252\n90:     C49 10.78285857\n91:     C18 11.15150331\n92:     C64 12.25743752\n93:     C43 17.41846385\n94:     C62 22.11868425\n95:     C34 30.78183558\n96:     C44 43.13143429\n    ICDCode         Inc\n\n\nHiába nem is létezik Inc nevű változó az eredeti adattáblában, ez a hívás mégis tökéletesen fog működni! Megint csak: azért, mert a második index már az első indexeléssel átalakított táblát kapja meg, és azt látja, pontosan ugyanúgy, mintha az egy lementett tábla lenne.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#referencia-szemantika",
    "href": "datatable.html#referencia-szemantika",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.7 Referencia szemantika",
    "text": "5.7 Referencia szemantika\nA data.table bevezet egy új megközelítést arra, hogy új változót definiáljunk egy táblában – ám hamar ki fog derülni, hogy itt jóval többről van szó, mint egyszerűen egy alternatív jelölésről.\nPéldául számoljuk ki, és ezúttal a táblázatban is tároljuk el az incidenciákat13:\n\nRawData$Inc &lt;- RawData$N / RawData$Population * 1e5\n\nA data.table által bevezett új megoldás esetén az értékadás jele a :=, de ami talán még fontosabb, hogy ezt, elsőre elég meglepő módon, úgy kell megadni, mintha indexelnénk, tehát szögleges zárójelek között! A második pozícióba, az oszlopindex helyébe kell kerüljön:\n\nRawData[, Inc2 := N / Population * 1e5]\n\nA kettő valóban ugyanazt eredményezi:\n\nidentical(RawData$Inc, RawData$Inc2)\n\n[1] TRUE\n\n\nEbben van egy újdonság: az összes eddigi példában új táblát hoztunk létre (még ha csak ki is írattuk, és nem mentettük el változóba), ez az első eset, ahol meglevő táblát módosítunk. Ez nagyon fontos: mint láthatjuk is, nem kell az eredményt belementenünk egy változóba, azért nem, mert az utasítás lefuttatásakor maga az eredeti tábla módosult! Ezt szokták az informatikában referencia szerinti módosításnak14 hívni. (És igen, ezt az indexelés szintaktikájával éri el a data.table, még ha elég meglepő is első látásra.)\nKiíratás ilyenkor ugyanúgy nincs, mint általában az értékadásos utasításoknál R-ben. Ha szeretnénk az értékadás után rögtön ki is íratni a táblát akkor egy [] jelet kell tennünk a parancs után, pl. RawData[, Inc2 := N / Population * 1e5][].\nHasználhatjuk ezt a megoldást meglevő változó felülírására, nem csak új létrehozására. Például, ha meggondoljuk magunkat, és az incidenciát per millió fő mértékegységben szeretnénk megadni:\n\nRawData[, Inc2 := Inc2 * 10]\n\nEgyszerre több változót is definiálhatunk (lehet vegyesen új definiálása és régi felülírása, ennek nincs jelentősége), ennek módszere:\n\nRawData[, c(\"logPop\", \"sqrtPop\") := list(log(Population),\n                                         sqrt(Population))]\n\nMivel az értékadás bal oldalán sztring-vektor áll, így könnyen előállítható gépi úton is. A jobb oldalon pedig lista szerepel, így itt is igaz, hogy nem muszáj kézzel felsorolni, bármilyen olyan függvény szerepelhet ott, ami listát ad vissza.\nVáltozó törölhető is ilyen módon:\n\nRawData[, Inc2 := NULL]\n\nHa több változót törölnénk:\n\nRawData[, c(\"logPop\", \"sqrtPop\") := NULL]\n\nMi értelme van mindennek? Az első válasz az, hogy bizonyos esetekben gyorsabb15. A második, hogy mindez kombinálható a data.table többi elemével, tehát a sorindexeléssel és a csoportosítással.\nPéldául szeretnénk a „Budapest” kifejezést lecserélni arra, hogy „Főváros” a megye változóban. Ezt megoldhatjuk így:\n\nRawData[County == \"Budapest\", County := \"Főváros\"]\n\nTehát: ha az értékadást szűréssel kombináljuk, akkor a nem kiválasztott soroknál nem változik az érték. (Ha pedig nem meglevő változót módosítunk, hanem újat hozunk létre, akkor a nem kiválasztott soroknál NA kerül az új változóba.)\nEzt könnyen megoldhattuk volna másképp is, de nézzük egy izgalmasabb példát. Szeretnénk minden nemre, életkorra, megyére és ráktípusra eltárolni, hogy az adott nemből, életkorból, megyéből és ráktípusból mi volt a legkisebb feljegyzett incidencia (a különböző évek közül, tehát). Ezt data.table nélkül csak macerásabban tudnánk megtenni, de a data.table használatával nagyon egyszerű (és nagyon logikus) a megoldás:\n\nRawData[, MinInc := min(Inc), .(County, Sex, Age, ICDCode)]\n\nA csoportosító változót kell használnunk, ami teljesen logikus is: képezi a csoportokat nem, életkor, megye és ráktípus szerint (tehát az egyes csoportokban a különböz évek fognak szerepelni), veszi azok körében az Inc minimumát, és azt menti el MinInc néven – az adott csoport különböző soraihoz mindig ugyanazt az értéket. Íme:\n\nRawData[ICDCode == \"C18\" & Age == 70 & County == \"Főváros\"]\n\n     County    Sex   Age  Year ICDCode     N Population      Inc   MinInc\n     &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;    &lt;num&gt;    &lt;num&gt;\n 1: Főváros  Férfi    70  2000     C18    97    30697.5 315.9866 217.0223\n 2: Főváros  Férfi    70  2001     C18   111    32326.5 343.3715 217.0223\n 3: Főváros  Férfi    70  2002     C18   108    31711.5 340.5705 217.0223\n 4: Főváros  Férfi    70  2003     C18    99    30984.0 319.5198 217.0223\n 5: Főváros  Férfi    70  2004     C18   100    30205.5 331.0655 217.0223\n 6: Főváros  Férfi    70  2005     C18    97    29194.5 332.2544 217.0223\n 7: Főváros  Férfi    70  2006     C18    90    28123.5 320.0171 217.0223\n 8: Főváros  Férfi    70  2007     C18    96    27422.5 350.0775 217.0223\n 9: Főváros  Férfi    70  2008     C18    95    27080.5 350.8059 217.0223\n10: Főváros  Férfi    70  2009     C18   102    26957.0 378.3804 217.0223\n11: Főváros  Férfi    70  2010     C18    80    27335.5 292.6597 217.0223\n12: Főváros  Férfi    70  2011     C18    97    28288.0 342.9016 217.0223\n13: Főváros  Férfi    70  2012     C18    89    30601.5 290.8354 217.0223\n14: Főváros  Férfi    70  2013     C18   118    32451.0 363.6252 217.0223\n15: Főváros  Férfi    70  2014     C18   108    34269.5 315.1490 217.0223\n16: Főváros  Férfi    70  2015     C18   103    35428.0 290.7305 217.0223\n17: Főváros  Férfi    70  2016     C18   107    35831.5 298.6199 217.0223\n18: Főváros  Férfi    70  2017     C18   101    36012.0 280.4621 217.0223\n19: Főváros  Férfi    70  2018     C18    78    35941.0 217.0223 217.0223\n20: Főváros     Nő    70  2000     C18   115    52434.0 219.3233 161.1007\n21: Főváros     Nő    70  2001     C18    99    53138.5 186.3056 161.1007\n22: Főváros     Nő    70  2002     C18    95    51751.0 183.5713 161.1007\n23: Főváros     Nő    70  2003     C18   110    50498.5 217.8283 161.1007\n24: Főváros     Nő    70  2004     C18    92    49073.0 187.4758 161.1007\n25: Főváros     Nő    70  2005     C18   102    47308.5 215.6061 161.1007\n26: Főváros     Nő    70  2006     C18    74    45934.0 161.1007 161.1007\n27: Főváros     Nő    70  2007     C18    95    45165.0 210.3399 161.1007\n28: Főváros     Nő    70  2008     C18    94    44594.5 210.7883 161.1007\n29: Főváros     Nő    70  2009     C18    84    44558.5 188.5162 161.1007\n30: Főváros     Nő    70  2010     C18    81    45258.5 178.9719 161.1007\n31: Főváros     Nő    70  2011     C18   101    46479.0 217.3024 161.1007\n32: Főváros     Nő    70  2012     C18   104    48132.0 216.0725 161.1007\n33: Főváros     Nő    70  2013     C18   134    50451.0 265.6042 161.1007\n34: Főváros     Nő    70  2014     C18   124    52854.0 234.6085 161.1007\n35: Főváros     Nő    70  2015     C18    94    54534.5 172.3680 161.1007\n36: Főváros     Nő    70  2016     C18   120    55317.5 216.9295 161.1007\n37: Főváros     Nő    70  2017     C18    95    55986.5 169.6838 161.1007\n38: Főváros     Nő    70  2018     C18   113    56508.0 199.9717 161.1007\n     County    Sex   Age  Year ICDCode     N Population      Inc   MinInc",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#footnotes",
    "href": "datatable.html#footnotes",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "",
    "text": "Arra azért vigyázni kell, hogy van példa arra, hogy pontosan ugyanaz a hívás mást ad vissza a data frame-nél és data table-nél. Egyébként ez a válasz arra a gyakran felmerülő kérdésre, hogy ha olyan jó a data.table, akkor miért nem győzik meg egyszerűen a fejlesztői az R fejlesztőit, hogy építsék be a tulajdonságait az R-es alap data frame-be is. Egyébként volt példa ilyenre is, de az előbbi ok miatt ez nem lehet általános, hiszen ez azt jelentené, hogy meglevő kódok működése is megváltozna, ami végeláthatlan sok R kód működését ronthatná el. Ilyen módosítást ma már nem igen lehet megtenni a data.frame-mel.↩︎\nA kód folytatható, ami finomabb felbontást ad, például a C00.0 a felső ajak külső felszínének daganata, a C00.1 az alsó ajak külső felszínének daganata stb., de a táblázatunk a háromjegyű besorolást tartalmazza.↩︎\nEz ún. évközepi lélekszám, tehát az év alatti – folyamatosan változó – lélekszámok átlaga. Ezért lehet az értéke törtszám is.↩︎\nEzek egy részénél nem kell külön függvényt hívni, csak „maga a data table” gyorsabb lesz mint a data frame. Más részénél szükség van egy külön függvényre, például a táblaegyesítésnél a merge-re. De ez is gyorsabb lesz, aminek a hátterében az van, hogy a data.table-nek van saját, ugyanilyen nevű függvénye (data.table::merge), és ez fog a data frame-hez tartozó alapváltozat, tehát a base::merge helyett futni.↩︎\nEgész pontosan annyit, amennyi a max.print opció értéke; ez a getOption(\"max.print\") paranccsal kérdezhető le. Az alapbeállítása tipikusan 1000.↩︎\nA precizitás kedvéért: ezt csak akkor teszi, ha a sorok száma nagyobb mint a datatable.print.nrows opció értéke, ami alapbeállítás szerint 100. De ez is logikus: kis adatbázisnál érdemes az egészet kiíratni, hiszen úgy is áttekinthető, nagyoknál lesz fontos csak az első néhány és az utolsó néhány sor kiíratása.↩︎\nEgyébként ez utóbbi esetben nem ugyanaz az order fut le: a data.table definiál egy saját order-t, tehát az előbbi esetben a base::order, az utóbbinál a data.table::order fut. A data.table csomag order-je egyébként is okosabb, például sokkal kényelmesebb ha több változó szerint és változó irányban kell rendeznünk: egyszerűen fel kell sorolnunk az order-en belül a változókat, és amelyik szerint csökkenő sorrendben akarunk rendezni, ott ki kell tennünk a változó neve elé egy - jelet.↩︎\nValójában van egy különbség, ami akkor jelentkezik, ha a kiválasztandó oszlopok neveit eltároljuk egy változóban, és az indexelésnél ezt a változót szeretnénk felhasználni ahelyett, hogy kézzel beírjuk a neveket. Legyen például colsel &lt;- c(\"Year\", \"N\", \"Population\"). Ekkor a data frame-nél mindegy, hogy a RawDataDF[, c(\"Year\", \"N\", \"Population\")] vagy a RawDataDF[, colsel] formát használjuk, az eredmény ugyanaz lesz. Ami logikus is, hiszen látszólag ugyanazt írtuk be kétszer. Nagyon meglepő módon azonban a data table-nél nem mindegy: a RawData[, c(\"Year\", \"N\", \"Population\")] működni fog, de a RawData[, colsel] nem! Ennek az az oka, hogy RawData[, colsel] összeakad egy szintaktikával, amit később fogunk látni, és amelyben ez azt jelentené, hogy „válaszd ki a colsel nevű oszlopot és add vissza vektorként”. Ami természetesen nem fog sikerülni, hiszen ilyen nevű oszlop nincs. Van azonban megoldás: ha erre volna szükségünk akkor vagy a RawData[, ..colsel] vagy a RawData[, colsel, with = FALSE] alakot kell használnunk.↩︎\nEz elsőre meglepő lehet, de valójában teljesen logikus: ha visszaemlékszünk, akkor már a data.frame-nél is láttuk, hogy az igazából az oszlopokból, mint vektorokból alkotott lista. Innen nézve teljesen érthető, hogy az oszlopokat egy lista elemeiként kell felsorolni!↩︎\nEz nem nyilvánvaló: a RawDataDF[, \"Year\"] egy vektor lesz! Természetesen a RawDataDF[, c(\"Year\", \"County\")] megint csak data frame; vagyis lényegében az történik, hogy a data frame automatikusan egyszerűsít: ha lehet – azaz egyetlen változót (oszlopot) választottunk ki – akkor egyszerűsíti vektorrá, ha nem, mert többet, akkor marad a data frame. Ez kényelmes is lehet, de közben mégis csak egy inkonzisztencia, hogy ugyanolyan típusú hívások eredménye teljesen eltérő adatstruktúra is lehet. Ezzel szemben a data.table-nél a RawData[, .(...)] típusú hívások mindig data table-t adnak vissza.↩︎\nElvileg a RawData[, Year] is használható, de ezt talán jobb kerülni, ritkán fordul elő.↩︎\nÉszrevehető, hogy az eredmény egy szám lesz, nem egy data table. Ennek az oka, hogy a .N – hiába van a nevében egy . – nem egy lista. Ha data frame-et szeretnénk visszakapni, akkor a korábbiakkal összhangban azt kell írnunk, hogy .(.N).↩︎\nAz összes fenti esetben ezt el tudtuk kerülni, és jobb is elkerülni: gondoljunk arra, hogy ha csoportosítást is csinálunk, akkor ezekkel az előre kiszámolt rétegenkénti incidenciákkal nem megyünk semmire. (Általában is igaz, hogy a kiszámítható dolgok közül csak azokat érdemes fizikailag letárolni az adatbázisban, amik kiszámítása sok időt venne igénybe.) Tehát ez most szigorúan csak illusztratív példa új változó létrehozására.↩︎\nEz problémát jelenthet akkor, ha egy függvényen belül csinálunk ilyet, hiszen ez azt fogja maga után vonni, hogy a bemenetként átadott adattábla át fog alakulni. Ez esetben a copy függvény segíthet: ezzel készíthetünk első lépésben egy másolatot a tábláról, és ha utána azon dolgozunk, akkor az eredeti, bemenetként megkapott tábla nem fog átalakulni.↩︎\nAz R a 3.1.0-s verzió előtt minden ilyen változó-értékadási műveletnél deep copy-t csinált az adatbázisról, ami azt jelenti, hogy nem csak a memóriamutatókat frissítette (ez lenne a shallow copy), hanem az egész adatbázist fizikailag átmásolta egy másik memóriaterületre. Ez nagyon gazdaságtalan, pláne, mert értelmetlen is, hiszen egy új változó definiálásától a meglevő tartalom maradhatna ugyanott. Ezt a 3.1.0-s verzióban orvosolták, de az továbbra is megmaradt, hogy nem az egész oszlop kap értéket, csak egy része, akkor deep copy készül. Ezzel szemben a data.table minden esetben és minden verzióban shallow copy-t csinál értékadásnál.↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  }
]