<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="hu-HU" xml:lang="hu-HU"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Ez a jegyzet bevezetést nyújt az R nyelv és számítási környezet használatába, mely a statisztikai, adatelemzési feladatok megoldásának egy nagyon erőteljes eszköze.">

<title>4&nbsp; Az R programozása – Bevezetés az R nyelv és statisztikai számítási környezet használatába</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./datatable.html" rel="next">
<link href="./fuggveny.html" rel="prev">
<link href="./Rlogo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-70a47bd5681a7291082a5b9f83d58762.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nincs találat",
    "search-matching-documents-text": "találat",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "További találatok elrejtése",
    "search-more-match-text": "további találat ebben a dokumentumban",
    "search-more-matches-text": "további találat ebben a dokumentumban",
    "search-clear-button-title": "Törlés",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Mégse",
    "search-submit-button-title": "Keresés",
    "search-label": "Keresés"
  }
}</script>


<meta property="og:title" content="4&nbsp; Az R programozása – Bevezetés az R nyelv és statisztikai számítási környezet használatába">
<meta property="og:description" content="Ez a jegyzet bevezetést nyújt az R nyelv és számítási környezet használatába, mely a statisztikai, adatelemzési feladatok megoldásának egy nagyon erőteljes eszköze.">
<meta property="og:image" content="https://ferenci-tamas.github.io/r-nyelv/cover.png">
<meta property="og:site_name" content="Bevezetés az R nyelv és statisztikai számítási környezet használatába">
<meta property="og:image:height" content="630">
<meta property="og:image:width" content="1200">
<meta name="twitter:title" content="4&nbsp; Az R programozása – Bevezetés az R nyelv és statisztikai számítási környezet használatába">
<meta name="twitter:description" content="Ez a jegyzet bevezetést nyújt az R nyelv és számítási környezet használatába, mely a statisztikai, adatelemzési feladatok megoldásának egy nagyon erőteljes eszköze.">
<meta name="twitter:image" content="https://ferenci-tamas.github.io/r-nyelv/cover.png">
<meta name="twitter:image-height" content="630">
<meta name="twitter:image-width" content="1200">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./programozas.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Az R programozása</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Keresés" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Bevezetés az R nyelv és statisztikai számítási környezet használatába</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/ferenci-tamas/r-nyelv" title="Forráskód" class="quarto-navigation-tool px-1" aria-label="Forráskód"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Letöltés" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Letöltés"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./ferenci-tamas-r-nyelv.pdf">
              <i class="bi bi-file-pdf pe-1"></i>
            Letöltés PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./ferenci-tamas-r-nyelv.epub">
              <i class="bi bi-journal pe-1"></i>
            Letöltés ePub
            </a>
          </li>
      </ul>
    </div>
    <div class="dropdown">
      <a href="" title="Megosztás" id="quarto-navigation-tool-dropdown-1" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Megosztás"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-1">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Keresés"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Előszó</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-szkript-rstudio.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">R szkriptek és az RStudio</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./adattipus-adatszerkezet.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Adattípusok, adatszerkezetek</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fuggveny.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Függvények</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programozas.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Az R programozása</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./datatable.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Data table: egy továbbfejlesztett adatkeret</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tartalomjegyzék</h2>
   
  <ul>
  <li><a href="#ismétlődő-feladat-kezelése-saját-függvénnyel" id="toc-ismétlődő-feladat-kezelése-saját-függvénnyel" class="nav-link active" data-scroll-target="#ismétlődő-feladat-kezelése-saját-függvénnyel"><span class="header-section-number">4.1</span> Ismétlődő feladat kezelése saját függvénnyel</a></li>
  <li><a href="#ciklusszervezés" id="toc-ciklusszervezés" class="nav-link" data-scroll-target="#ciklusszervezés"><span class="header-section-number">4.2</span> Ciklusszervezés</a></li>
  <li><a href="#funkcionális-programozás" id="toc-funkcionális-programozás" class="nav-link" data-scroll-target="#funkcionális-programozás"><span class="header-section-number">4.3</span> Funkcionális programozás</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/ferenci-tamas/r-nyelv/edit/main/programozas.qmd" class="toc-action"><i class="bi bi-github"></i>Az oldal szerkesztése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/blob/main/programozas.qmd" class="toc-action"><i class="bi empty"></i>Forráskód megtekintése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/issues/new" class="toc-action"><i class="bi empty"></i>Észrevétel jelzése</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Az R programozása</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Az eddigieket felhasználva elkezdhetünk megismerkedni az R programozásának alapvető módszereivel és fortélyaival. Ezek egyszerűbb problémák megoldására önmagában alkalmasak, a bonyolultabb feladatok esetén pedig építőelemként szolgálnak, melyek használata lehetővé teszi komplex programok létrehozását.</p>
<p>A következőkben mindenhol a már látott, születési tömeges adatbázist fogjuk példaként használni:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(birthwt, <span class="at">package =</span> <span class="st">"MASS"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>birthwt<span class="sc">$</span>race <span class="ot">&lt;-</span> <span class="fu">factor</span>(</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  birthwt<span class="sc">$</span>race, <span class="at">levels =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"Kaukázusi"</span>, <span class="st">"Afro-amerikai"</span>, <span class="st">"Egyéb"</span>))</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="ismétlődő-feladat-kezelése-saját-függvénnyel" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="ismétlődő-feladat-kezelése-saját-függvénnyel"><span class="header-section-number">4.1</span> Ismétlődő feladat kezelése saját függvénnyel</h2>
<p>Kezdjünk egy egyszerű feladattal: határozzuk meg az átlagos születési tömeget a különböző rasszhoz tartozó anyák körében!</p>
<p>Kezdjük a kaukázusi rasszal. A feladat valóban nem túl bonyolult: elsőként le kell szűkíteni az adatbázist (ehhez használjuk a logikai vektorral történő indexelést, ahol a vektort természetesen gépi úton, összehasonlítással állítjuk elő), kiválasztani a megfelelő oszlopot, majd venni az átlagát:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(birthwt[birthwt<span class="sc">$</span>race <span class="sc">==</span> <span class="st">"Kaukázusi"</span>,]<span class="sc">$</span>bwt)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3102.719</code></pre>
</div>
</div>
<p>A feladat teljesen hasonlóan oldható meg a másik két rasszal:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(birthwt[birthwt<span class="sc">$</span>race <span class="sc">==</span> <span class="st">"Afro-amerikai"</span>,]<span class="sc">$</span>bwt)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2719.692</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(birthwt[birthwt<span class="sc">$</span>race <span class="sc">==</span> <span class="st">"Egyéb"</span>,]<span class="sc">$</span>bwt)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2805.284</code></pre>
</div>
</div>
<p>E kódsorokra ránézve remélhetőleg mindenkiben megszólal a vészcsengő: ebben rengeteg redundancia, ismétlődés van. (Ha valakinek ez így nem lenne kellően drámai, akkor gondoljon arra, hogy mi van, ha nem 3, hanem 30 kategóriánk van!) De erre már láttuk a megoldást: saját függvényt kell írni! Jelen esetben ez így nézhet ki:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>racemean <span class="ot">&lt;-</span> <span class="cf">function</span>(race) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mean</span>(birthwt[birthwt<span class="sc">$</span>race <span class="sc">==</span> race,]<span class="sc">$</span>bwt)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Ha valaki még nem írt ilyet, akkor egy dolog szokott nehézséget jelenteni, az argumentum kezelése. Eleinte ugyanis furcsa lehet, hogy megjelent egy <code>race</code> változó (mi az értéke? mit jelent ez? sehol nem definiáltunk ilyet!). Ha valakit ez megzavarna, akkor egyetlen dologra kell emlékeznie: mindenhol, ahol <code>race</code>-t lát, oda kell képzelnie, hogy <code>"Kaukázusi"</code>! (Vagy bármelyik másik kategóriát.) A válasz a kérdésre ugyanis az, hogy ennek az az értéke, amit a felhasználó megad a függvény hívásakor (ami persze bármi lehet, ezért lesz ez változó); arról pedig az R gondoskodik, hogy valóban ez kerüljön ebbe a változóba. Igen, mi nem definiáltunk ilyen változót, de a függvény futásának idejére lesz ilyen, pontosan ugyanúgy, mint egy általunk létrehozott változó, ezt az R fogja intézni. Erre gondolva kell megírni a függvényt.</p>
<p>E saját függvény használatával így nézhet ki a probléma megoldása:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">racemean</span>(<span class="st">"Kaukázusi"</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3102.719</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">racemean</span>(<span class="st">"Afro-amerikai"</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2719.692</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">racemean</span>(<span class="st">"Egyéb"</span>)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2805.284</code></pre>
</div>
</div>
</section>
<section id="ciklusszervezés" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="ciklusszervezés"><span class="header-section-number">4.2</span> Ciklusszervezés</h2>
<p>A fenti megoldás nagyon sokat javított a redundancián, de azért egy kis hiányérzetünk maradhat: a <code>racemean</code> így is háromszor van leírva. Miért? Lényegében arról van szó, hogy ugyanazt a műveletet kell többször egymás után végrehajtani (csak más adatokon). Az ilyen ismétlődő – szó szerint azonos, vagy legalábbis hasonló – kódok végrehajtása megint csak egy redundancia-probléma. És a megoldás itt is ugyanaz: ne kézzel másolgassuk le többször egymás alá! Ha azonos műveletet kell végrehajtani, akkor csak adjuk meg, hogy mit és hányszor, ha pedig hasonlót, akkor legyen egy változó, ami különböző értékeket vesz fel, megtestesítve az eltérést a többszöri futtatások között, és egyszer adjuk meg a kódot (ami természetesen függeni fog ettől a változótól). Az ilyet szokták a programozáselméletben ciklusnak vagy iterációnak hívni; nagyon sokszor merül ez fel a gyakorlatban. Az R egyik nagyon fontos eltérése más programnyelvektől, hogy hogyan kezeljük az ilyen helyzeteket.</p>
<p>Más programnyelveken általában explicite, kézzel kell megszerveznünk a ciklust: meg kell adnunk a kódrészletet amit újra meg újra megismétlünk, meg kell adni, hogy ez az ismételtetés hogyan történjen (milyen változó és hogyan változzon közben, meddig tartson a ciklus), az R-nél azonban nem ez a helyzet: az esetek túlnyomó többségében egy függvényt, az <code>apply</code>-függvénycsalád valamelyik tagját kell használni erre a célra. Itt például bevethetjük az <code>lapply</code>-t:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"Kaukázusi"</span>, <span class="st">"Afro-amerikai"</span>, <span class="st">"Egyéb"</span>), racemean)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] 3102.719

[[2]]
[1] 2719.692

[[3]]
[1] 2805.284</code></pre>
</div>
</div>
<p>Mi történik itt? Az <code>lapply</code> egy kétargumentumú függvény, az első argumentuma egy vektor, a második egy függvény. Az <code>lapply</code> azt csinálja, hogy a második argumentumban megadott függvényt egyesével ráereszti az első argumentumban megadott vektor minden egyes elemére (azaz meghívja a függvényt rájuk, mint argumentumra), és a kapott visszatérési értékeket összefűzi egy listába. (Innen az <code>l</code> betű a függvény nevének az elején: ez mindenképp listát ad vissza.) Ezzel a módszerrel lényegében létrehoztunk egy ciklust.</p>
<p>Gyakran használjuk még az <code>sapply</code>-t is, itt az <code>s</code> betű arra utal, hogy simplified, azaz egyszerűsített: ha az <code>lapply</code> olyan eredményt ad, ahol a lista valamilyen egyszerűbb objektumra konvertálható, akkor az <code>sapply</code> ezt megteszi. Itt erről van szó, hiszen a lista minden eleme egyetlen szám, így az egyszerűbb objektum kézenfekvő lesz: egy vektor<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Az <code>sapply</code>-jal valóban erre jutunk:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(<span class="fu">c</span>(<span class="st">"Kaukázusi"</span>, <span class="st">"Afro-amerikai"</span>, <span class="st">"Egyéb"</span>), racemean)</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Kaukázusi Afro-amerikai         Egyéb 
     3102.719      2719.692      2805.284 </code></pre>
</div>
</div>
<p>És íme, a végleges, redundancia-mentes, elegáns, R-stílusú megoldás<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>!</p>
<p>Egy pillanatra visszatérnék még a „más programnyelvekben szokásos megoldások” kitételre. A legtipikusabb példa a <code>for</code>-ciklus; ez elvileg R-ben is megvalósítható: meg kell adni egy vektort, egy változónevet<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> és egy kódot, az R pedig újra meg újra lefuttatja a kódot úgy, hogy a változó közben egyesével felveszi a vektorban foglalt értékeket<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. A fenti példa ezért így nézhet ki <code>for</code>-ciklussal:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(race <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Kaukázusi"</span>, <span class="st">"Afro-amerikai"</span>, <span class="st">"Egyéb"</span>)) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">racemean</span>(race)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>A szépséghiba, hogy így csak kiírattuk az értékeket, de nem mentettük el változóba. Ezt megtehetjük például így, létrehozva egy – eleinte üres – számvektort az eredmények tárolására, és minden ciklusban hozzáfűzve az új eredményt a vektor végére:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">numeric</span>()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(race <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Kaukázusi"</span>, <span class="st">"Afro-amerikai"</span>, <span class="st">"Egyéb"</span>)) {</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">c</span>(res, <span class="fu">racemean</span>(race))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>res</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3102.719 2719.692 2805.284</code></pre>
</div>
</div>
<p>Ez a megoldás működik, de nagyon szerencsétlen és kerülendő: a probléma az, hogy ez esetben a R-nek minden egyes ciklusban újra kell foglalnia a memóriát a <code>res</code> számára és átmásolnia az új helyre; ez veszteség, lassú lesz. Éppen ezért ilyen esetekben mindig az a jó megoldás, ha preallokálunk, tehát előre lefoglaljuk a memóriát a <code>res</code> végleges méretével, és a ciklusban mindig a megfelelő helyre tesszük az eredményt:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>races <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Kaukázusi"</span>, <span class="st">"Afro-amerikai"</span>, <span class="st">"Egyéb"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="fu">length</span>(races))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">seq_along</span>(races)) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  res[i] <span class="ot">&lt;-</span> <span class="fu">racemean</span>(races[i])</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>res</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3102.719 2719.692 2805.284</code></pre>
</div>
</div>
<p>(A <code>seq_along</code> funkciójában teljesen hasonló az <code>1:length(races)</code>-hez, ami valószínűleg az ember első gondolata lenne a fenti helyzetben. A <code>seq_along</code> azért jobb, mert ha a vektor hossza véletlenül nulla, akkor az utóbbi megoldás az <code>c(1, 0)</code> vektoron futtatná végig a ciklust, hiszen a <code>:</code> csökkenő sorozatot is tud generálni, míg a <code>seq_along</code> – helyesen – semmin, ugyanis a <code>seq_along(x)</code> hossza mindig azonos lesz <code>x</code> hosszával. A fenti esetben a dolognak nincs jelentősége, hiszen pontosan tudjuk mi lesz a <code>races</code>, de jobb a hibaállóbb megoldást megszokni.)</p>
<p>Talán már a fenti kód is sugallja, hogy miért jobb az <code>sapply</code> a maga 1, azaz egy sorával… A különbség oka egyszerűen az, hogy az <code>sapply</code> megcsinál helyettünk egy sor dolgot, amit a <code>for</code> ciklus esetén nekünk, kézzel kellett elintéznünk: memóriát foglal, végigmegy az elemeken, gondoskodik róla, hogy minden a megfelelő helyre kerüljön stb. Mi ennek az oka? Az <code>sapply</code> írói okosak, de legalábbis kedvesek voltak, hogy nekünk kevesebb munkák legyen, a <code>for</code> írói viszont megsavanyodott programozók, akik szeretnék, ha sokat dolgozhatunk? Nem. Ez azért van, mert a <code>for</code> flexibilisebb: igaz, hogy az <code>sapply</code> ezeket mind megteszi helyettünk, viszont cserében mást nem is választhatunk, a <code>for</code> esetén viszont megtehetjük, hogy minden második elemet mentjük csak el egy vektorba, ettől függetlenül minden harmadikat kiíratjuk, és minden negyediket dallamá konvertáljuk, majd feltöltjük a Youtube-ra. Vagy, hogy mondjak egy földhözragadtabb (és talán a gyakorlatban is sűrűbben előforduló…) példát: <code>for</code>-ciklussal tudunk hivatkozni a <em>többi</em> elemre, például az előző iterációra, <code>sapply</code>-jal ez nem tehető meg. A konklúzió tehát egyszerű: ha nekünk <em>pont</em> arra van szükségünk, amit az <code>sapply</code> kínál – tehát az egymástól függetlenül kiszámítható visszatérési értékek összefogva egy vektorba – és nagyon sokszor erre lesz, mert nem véletlen, hogy az <code>sapply</code> pont ezt kínálja, akkor használjuk azt, ha nem erre, hanem valami általánosabbra, akkor használjuk a <code>for</code>-t. Megjegyzem, hogy ez egyébként egy teljesen általános tervezési elv is a programozásban: mindig a lehető <em>legkevésbé</em> flexibilist eszközt használjuk azok közül, amik már elég flexibilisek a problémánk megoldásához.</p>
<p>Valójában egyébként nem egyszerűen a rövidség a fő kérdés<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, hanem az olvashatóság, értelmezhetőség, de ami valójában még ennél is fontosabb, hogy az <code>apply</code> család sokkal jobban megfelel az R filozófiájának, mint a <code>for</code>-ciklus. Erről a következő pontban lesz részletesen szó.</p>
<p>A dolog végkonklúziója egyszerűen összefoglalható: R-ben ne használjunk <code>for</code>-ciklust! Szinte minden esetben igaz, hogy a <code>for</code>-ciklus kiváltható megfelelő <code>apply</code>-jal, és ki is váltandó.</p>
<p>Az egyetlen kivétel, ha mellékhatásos számítást végzünk, például fájlba kell mentenünk. Ez esetben az <code>apply</code>-család nem igazán esik kézre (hiszen nincs is visszatérési érték, de legalábbis nem amiatt végezzük a számítást), így inkább elfogadható a <code>for</code>-ciklus is.</p>
<p>A más programnyelvekben megszokott hátultesztelő ciklus nincs az R-ben, elöltesztelő van<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. A dolgot nem részletezem, hiszen már a <code>for</code>-ciklus használata is kerülendő, így erre végképp ritkán van szükség.</p>
<p>Egyetlen megjegyzés a végére. A fentiekben végig azt feltételeztem, hogy nem szó szerint ugyanazt a műveletet kell többször végrehajtani (igen, a kód ugyanaz volt, de az argumentum változott). Ha mégis erre volna szükség, akkor a <code>replicate</code> függvényt használhatjuk, mely a második argumentumban várja a többször megismétlendő kódot (egyetlen kifejezést, tehát ha nem egy soros a kód, akkor kapcsos zárójelekkel blokkot kell képezni), amit az első argumentumban megadott darabszámúszor lefuttat, és eredményeket összefűzi egy megfelelő objektumba (ha egyetlen számot adunk vissza, akkor vektorba). Ezt gyakran használjuk egyszerű Monte Carlo-szimulációkban. Például egy 30 elemű minta mintaátlagának viselkedését így szimulálhatjuk:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">replicate</span>(<span class="dv">10</span>, {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  minta <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">30</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mean</span>(minta)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>})</span></code></pre></div><button title="Vágólapra másolás" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  0.019809270  0.005074183  0.219660466  0.099975728 -0.087002354
 [6] -0.023933583 -0.059823543 -0.067466860  0.099464099  0.137874079</code></pre>
</div>
</div>
</section>
<section id="funkcionális-programozás" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="funkcionális-programozás"><span class="header-section-number">4.3</span> Funkcionális programozás</h2>
<p>Az előző pontban úgy vezettem be az <code>apply</code> családot, mint egy cseles programozástechnikai megoldást ciklusszervezésre. Valóban ez az egyik felfogás, de a mélyben sokkal fontosabb dolgok rejtőznek.</p>
<p>Ehhez kezdjünk egy tételmondattal: bár az R – mint a legtöbb mai programozási nyelv – többféle programozási paradigmát támogat, ami legközelebb áll hozzá, az a funkcionális programozás. Hogy még egyértelműbben fogalmazzak, az R egy funkcionális programozási nyelv.</p>
<p>Mit jelent ez? A programozáselméletben szoktak beszélni két programozási alapfilozófiáról, programozási paradigmáról: az imperatív programozás az, ahol a programban konkrétan elő kell írnunk, hogy mit csináljon a számítógép, a deklaratív programozási paradigma pedig az, ahol azt írjuk le a programban, hogy mi az elérendő cél, a megvalósítást ez alapján már a gép fogja kitalálni. A deklaratív paradigma egyik altípusa a funkcionális programozás. A nevét a függvényről (angolul function) kapta, és csakugyan, a függvényeknek e paradigmában kiemelt szerepük van. Itt muszáj rögtön egy pontosítást tennünk. Függvények más programozási paradigmában is vannak, természetesen, akár még kiemelt szerepük is lehet, még egy imperatív programban is, de a funkcionális programozási paradigmában ennél többről van szó: itt nem csak <em>léteznek</em> függvények, hanem <em>csak</em> függvények léteznek. E paradigma egyik sarokköve ugyanis, hogy <em>mindent</em> függvények hívásával oldunk meg. Több más jellemzője is van a funkcionális nyelveknek, lesz még néhányról itt is szó, de ez a legfontosabb. (Már itt is látszik, hogy miért mondtam, hogy ez az R valódi filozófiája – emlékezzünk csak vissza arra, hogy az R-ben minden függvényhívás…!)</p>
<p>Nézzünk egy egyszerű példát: ki akarjuk számolni az <code>n</code> pozitív egész szám faktoriálisát. Imperatív megoldás: legyen a <code>fact</code> változó értéke 1, majd fusson egy <code>for</code>-ciklus melyben az <code>i</code> ciklusváltozó megy <code>1</code>-től <code>n</code>-ig egyesével, és a ciklus minden iterációjában cseréljük le <code>fact</code> értékét <code>fact * i</code>-re. Ez egy imperatív megoldás volt, pontosan előírtuk a számítógépnek, lépésről-lépésre, hogy mit kell csinálnia. Ugyanez funkcionális felfogásban: legyen <code>fact(n)</code> egy függvény azzal a definícióval, hogy <code>1</code> a visszatérési értéke ha <code>n = 0</code>, egyébként a visszatérési értéke <code>n * fact(n - 1)</code>. Az is szépen látszik, hogy ezt miért hívják deklaratív paradigmának (nem előírtuk, hogy mit kell csinálni a kiszámításhoz, csak deklaráltuk, hogy a faktoriálisnak milyen tulajdonsága van – és innentől a gépre bízzuk, hogy ezt megoldja), de a mostani szempontunkból még érdekesebb, hogy mutatja, mitől funkcionális a paradigma: mindent függvények alkalmazásával oldunk meg, nincsen ciklus, még csak értékadás sincsen.</p>
<p>Fontos: a dolog célja egyáltalán nem feltétlenül az, hogy a kapott programunk gyorsabb legyen. Simán lehet, hogy végeredményben (gépi kód szintjén) a funkcionális megközelítéssel pont ugyanazt kapjuk, mint az imperatívval, sőt, elég tipikus, hogy a funkcionális még lassabb is. A cél az, hogy egyszerűbb, emiatt könnyebben megírható, kisebb valószínűséggel hibás, könnyebben ellenőrizhető, jobban optimalizálható kódunk legyen. Az előbbi példa is mutatja, hogy a funkcionális megközelítés átláthatóbb, egyszerűbben értelmezhető kódot eredményez, amiről sokkal könnyebben és gyorsabban látszik, hogy mit csinál a program, vajon helyes-e az. (Képzeljük el mindezt egy faktoriális-számításnál százszor nehezebb problémánál!)</p>
<p>A funkcionális programozási paradigma kiemelten jól illeszkedik az adatelemzési, statisztikai feladatokhoz. Amint volt róla szó, az R mást is támogat, így nem kötelező R-ben ezt használni… de <em>érdemes</em>! (Valójában az, hogy más, nem tisztán funkcionális eszközöket is támogat, még akkor is jól jön, ha <em>alapvetően</em> funkcionális szemléletben kódolunk: a teljesen vegytisztán funkcionális megoldások lehetnek nagyon nyakatekertek, ezért a gyakorlatban sokszor megkönnyíti az életet egy csipetnyi nem-funkcionális elem hozzákeverése az egyébként funkcionális kódhoz.)</p>
<p>Egy második példa lehet épp az előző alfejezet, hiszen ott mivel váltottuk ki a <code>for</code>-ciklust? Függvény-alkalmazással! A <code>lapply</code>, <code>sapply</code> mind függvény volt, ezek alkalmazásával értük el pontosan ugyanazt a célt.</p>
<p>Itt érdemes megjegyezni azt is, hogy ezek egész pontosan milyen függvények voltak: olyanok, amik paraméterként egy másik függvényt vártak. Az ilyeneket szokták magasabbrendű függvénynek nevezni, és a dolog nem véletlen: ezek nagyon gyakran fordulnak elő a funkcionális paradigmában. Magasabbrendű függvénynek nevezzük azokat a függvényeket is, amik függvényt adnak visszatérési értékként, sőt, olyan is lehet, hogy a függvény argumentumként is függvényt vár, és visszatérési értékként is függvényt ad.</p>
<p>Itt érünk el a funkcionális paradigma egyik tipikus jellemzőjéhez: ebben a megközelítésben a függvények, úgy szokták mondani, „elsőrendű állampolgárok”. Függvény ugyanúgy változó, mint bármilyen más változó, függvény átadható argumentumként, azaz van függvény, ami bemenetként függvényt vár, sőt, írhatunk függvényt, ami függvényt ad vissza visszatérési értékként. Egyszóval: ahol lehet valamilyen változó, ott lehet függvény is.</p>
<p>Egy másik fontos jellemző a tiszta függvények alkalmazására törekvés. Idézzük fel a tiszta függvény definícióját: ez olyan függvény, aminek nincs mellékhatása <em>és</em> a visszatérési értékét determinisztikusan meghatározzák az argumentumai, vagyis ugyanahhoz az argumentumhoz mindig ugyanaz a visszatérési érték tartozik. Ha a kettő egyszerre teljesül, akkor nevezzük a függvényt tisztának. Az első feltétel megsértése miatt nem tiszta függvény például a <code>print</code> vagy a <code>write.csv2</code>, de az értékadás (<code>&lt;-</code>) sem, a második feltétel megsértése miatt nem tiszta függvény az <code>rnorm</code>, de a <code>Sys.time</code> sem. (Itt utalnék vissza a korábbi megjegyzésemre arról, hogy a gyakorlatban általában nem vagyunk vegytisztán funkcionálisak: képzeljünk el olyan adatelemzést, amiben nem írhatunk ki eredményt, nem adhatunk értéket változónak, vagy amiben nem generálhatunk véletlenszámokat…!) Nem lehet tehát mindig tiszta függvényeket használni, és ez nem is baj – ki kell használni annak az erejét, hogy az ilyen helyeken nyakatekertség helyett egy pici nem-funkcionális megoldást vetünk be – de a tiszta függvények elegánsabbak és jobban elemezhetőek.</p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Ez természetesen nem mindig van így: lehet, hogy a listában mondjuk adatkeretek vannak, akár az is előfordulhat, hogy az egyik elem egy szám, a másik egy adatkeret. Ilyenkor az <code>sapply</code> nem egyszerűsít, hiszen nem is tud. Az sem biztos, hogy mindig vektorrá egyszerűsít: ha a lista elemei vektorok, akkor mátrixszá fog egyszerűsíteni. Egyébként ez az oka annak, hogy van, aki nem ajánlja az <code>sapply</code> használatát nem interaktív kódban: nem tudható előre, hogy mi lesz az eredményének a típusa. Ezt a problémát <code>vapply</code> oldja meg, ahol ezt a típust meg kell adni, így a meghívása biztonságosabb – és kicsit gyorsabb is – mégis, ritkán használják.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Amely megoldás ebben az esetben egyébként teljesen felesleges, mert erre a konkrét szituációra van egy másik, kész R-függvény – a <code>tapply</code> – de itt a cél csak a módszerek demonstrációja volt.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Vigyázat, ha ilyen nevű változó már létezik, akkor az értéke felül fog íródni a <code>for</code>-ciklus végrehajtása során azokkal az értékekkel, amiket a változó a ciklusban felvesz, tehát, a vektorban lévő elemekkel.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Látható tehát, hogy egy megszorítás van: előre és pontosan meg kell adni, hogy a ciklusváltozó milyen értékeket fog felvenni. A programozáselméletben ezt gyakran igazából <code>foreach</code>-ciklusnak hívják, és a <code>for</code>-ciklus nevet fenntartják arra az esetre, amikor csak azt adjuk meg, hogy mettől-meddig menjen a ciklusváltozó (esetleg kiegészítve azzal, hogy milyen lépésközzel), vagy megadjuk, hogy mi legyen a kezdőértéke, milyen műveletet hajtsunk végre vele minden iterációban, és mikor álljon meg a ciklus.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Szokták e mellett még azt is mondani, hogy a gyorsaság szól az <code>apply</code> család mellett, mert a <code>for</code>-ciklus lassú, de ez már régen nem igaz: az R mostani verzióiban a <code>for</code>-ciklus már nagyjából ugyanolyan gyors.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Két verzióban is. A <code>while</code> szokásos elöltesztelő ciklus, a <code>repeat</code>-nél viszont nincs feltétel, ezért a végtelenségig futna, így értelme csak akkor van, ha manuálisan kiugrasztjuk a ciklusból, erre a <code>break</code> nevű utasítás szolgál (ezt egyébként <code>for</code>-ciklusban is használhatjuk). A <code>for</code> ciklus mindig átírható <code>while</code>-ra, a <code>while</code> pedig mindig átírható <code>repeat</code>-re, de fordítva nem feltétlenül. Ezért elvileg lehet olyan helyzet, hogy nem tudunk <code>for</code>-t, vagy <code>while</code>-t használni, de ha tudunk, akkor használjuk inkább azokat – itt is előjön megint ugyanaz, hogy a legkevésbé flexibilis eszköz lesz a jobb választás.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kimásolva!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kimásolva!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/ferenci-tamas\.github\.io\/r-nyelv");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./fuggveny.html" class="pagination-link" aria-label="Függvények">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Függvények</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./datatable.html" class="pagination-link" aria-label="Data table: egy továbbfejlesztett adatkeret">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Data table: egy továbbfejlesztett adatkeret</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/ferenci-tamas/r-nyelv/edit/main/programozas.qmd" class="toc-action"><i class="bi bi-github"></i>Az oldal szerkesztése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/blob/main/programozas.qmd" class="toc-action"><i class="bi empty"></i>Forráskód megtekintése</a></li><li><a href="https://github.com/ferenci-tamas/r-nyelv/issues/new" class="toc-action"><i class="bi empty"></i>Észrevétel jelzése</a></li></ul></div></div></div></footer><script type="text/javascript">
var sc_project=12422840; 
var sc_invisible=1; 
var sc_security="d32cce24"; 
</script>
<script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
<noscript><div class="statcounter"><a title="ingyenes
webstatisztika" href="https://www.statcounter.hu/" target="_blank"><img class="statcounter" src="https://c.statcounter.com/12422840/0/d32cce24/1/" alt="ingyenes webstatisztika" referrerpolicy="no-referrer-when-downgrade"></a></div></noscript>




</body></html>